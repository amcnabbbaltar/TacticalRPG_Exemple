<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>TBSF Documentation</title>
    <style>
      .markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;margin:0;color:#24292f;background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body h1:hover .anchor .octicon-link:before,.markdown-body h2:hover .anchor .octicon-link:before,.markdown-body h3:hover .anchor .octicon-link:before,.markdown-body h4:hover .anchor .octicon-link:before,.markdown-body h5:hover .anchor .octicon-link:before,.markdown-body h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:' ';display:inline-block;background-color:currentColor;-webkit-mask-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'%3E%3C/path%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'%3E%3Cpath fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'%3E%3C/path%3E%3C/svg%3E")}.markdown-body details,.markdown-body figcaption,.markdown-body figure{display:block}.markdown-body summary{display:list-item}.markdown-body [hidden]{display:none!important}.markdown-body a{background-color:transparent;color:#0969da;text-decoration:none}.markdown-body abbr[title]{border-bottom:none;text-decoration:underline dotted}.markdown-body b,.markdown-body strong{font-weight:600}.markdown-body dfn{font-style:italic}.markdown-body h1{margin:.67em 0;font-weight:600;padding-bottom:.3em;font-size:2em;border-bottom:1px solid #d7dde3}.markdown-body mark{background-color:#fff8c5;color:#24292f}.markdown-body small{font-size:90%}.markdown-body sub,.markdown-body sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.markdown-body sub{bottom:-.25em}.markdown-body sup{top:-.5em}.markdown-body img{border-style:none;max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body code,.markdown-body kbd,.markdown-body pre,.markdown-body samp{font-family:monospace;font-size:1em}.markdown-body figure{margin:1em 40px}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #d7dde3;height:.25em;padding:0;margin:24px 0;background-color:#d0d7de;border:0}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=button],.markdown-body [type=reset],.markdown-body [type=submit]{-webkit-appearance:button}.markdown-body [type=checkbox],.markdown-body [type=radio]{box-sizing:border-box;padding:0}.markdown-body [type=number]::-webkit-inner-spin-button,.markdown-body [type=number]::-webkit-outer-spin-button{height:auto}.markdown-body [type=search]::-webkit-search-cancel-button,.markdown-body [type=search]::-webkit-search-decoration{-webkit-appearance:none}.markdown-body ::-webkit-input-placeholder{color:inherit;opacity:.54}.markdown-body ::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.markdown-body a:hover{text-decoration:underline}.markdown-body ::placeholder{color:#6e7781;opacity:1}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:max-content;max-width:100%;overflow:auto}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body details:not([open])>:not(summary){display:none!important}.markdown-body [role=button]:focus,.markdown-body a:focus,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=radio]:focus{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible),.markdown-body input[type=checkbox]:focus:not(:focus-visible),.markdown-body input[type=radio]:focus:not(:focus-visible){outline:solid 1px transparent}.markdown-body [role=button]:focus-visible,.markdown-body a:focus-visible,.markdown-body input[type=checkbox]:focus-visible,.markdown-body input[type=radio]:focus-visible{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:not([class]):focus,.markdown-body a:not([class]):focus-visible,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=checkbox]:focus-visible,.markdown-body input[type=radio]:focus,.markdown-body input[type=radio]:focus-visible{outline-offset:0}.markdown-body kbd{display:inline-block;padding:3px 5px;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:10px;color:#24292f;vertical-align:middle;background-color:#f6f8fa;border:solid 1px rgba(175,184,193,.2);border-bottom-color:rgba(175,184,193,.2);border-radius:6px;box-shadow:inset 0 -1px 0 rgba(175,184,193,.2)}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h2{font-weight:600;padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #d7dde3}.markdown-body h3{font-weight:600;font-size:1.25em}.markdown-body h4{font-weight:600;font-size:1em}.markdown-body h5{font-weight:600;font-size:.875em}.markdown-body h6{font-weight:600;font-size:.85em;color:#57606a}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body ol,.markdown-body ul{margin-top:0;margin-bottom:0;padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code,.markdown-body samp,.markdown-body tt{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;word-wrap:normal}.markdown-body .octicon{display:inline-block;overflow:visible!important;vertical-align:text-bottom;fill:currentColor}.markdown-body input::-webkit-inner-spin-button,.markdown-body input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#cf222e}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:0}.markdown-body blockquote,.markdown-body details,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#24292f;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 code,.markdown-body h1 tt,.markdown-body h2 code,.markdown-body h2 tt,.markdown-body h3 code,.markdown-body h3 tt,.markdown-body h4 code,.markdown-body h4 tt,.markdown-body h5 code,.markdown-body h5 tt,.markdown-body h6 code,.markdown-body h6 tt{padding:0 .2em;font-size:inherit}.markdown-body summary h1,.markdown-body summary h2,.markdown-body summary h3,.markdown-body summary h4,.markdown-body summary h5,.markdown-body summary h6{display:inline-block}.markdown-body summary h1 .anchor,.markdown-body summary h2 .anchor,.markdown-body summary h3 .anchor,.markdown-body summary h4 .anchor,.markdown-body summary h5 .anchor,.markdown-body summary h6 .anchor{margin-left:-40px}.markdown-body summary h1,.markdown-body summary h2{padding-bottom:0;border-bottom:0}.markdown-body ol.no-list,.markdown-body ul.no-list{padding:0;list-style-type:none}.markdown-body ol[type=a]{list-style-type:lower-alpha}.markdown-body ol[type=A]{list-style-type:upper-alpha}.markdown-body ol[type=i]{list-style-type:lower-roman}.markdown-body ol[type=I]{list-style-type:upper-roman}.markdown-body ol[type="1"]{list-style-type:decimal}.markdown-body div>ol:not([type]){list-style-type:decimal}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #d0d7de}.markdown-body table tr{background-color:#fff;border-top:1px solid #d7dde3}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body table img{background-color:transparent}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #d0d7de}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#24292f}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:.2em .4em;margin:0;font-size:85%;white-space:break-spaces;background-color:rgba(175,184,193,.2);border-radius:6px}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body samp{font-size:85%}.markdown-body pre code{font-size:100%}.markdown-body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:6px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-num{padding:10px 8px 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:600;background:#f6f8fa;border-top:0}.markdown-body [data-footnote-ref]::before{content:"["}.markdown-body [data-footnote-ref]::after{content:"]"}.markdown-body .footnotes{font-size:12px;color:#57606a;border-top:1px solid #d0d7de}.markdown-body .footnotes ol{padding-left:16px}.markdown-body .footnotes ol ul{display:inline-block;padding-left:16px;margin-top:16px}.markdown-body .footnotes li{position:relative}.markdown-body .footnotes li:target::before{position:absolute;top:-8px;right:-8px;bottom:-8px;left:-24px;pointer-events:none;content:"";border:2px solid #0969da;border-radius:6px}.markdown-body .footnotes li:target{color:#24292f}.markdown-body .footnotes .data-footnote-backref g-emoji{font-family:monospace}.markdown-body .pl-c{color:#6e7781}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#0550ae}.markdown-body .pl-e,.markdown-body .pl-en{color:#8250df}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292f}.markdown-body .pl-ent{color:#116329}.markdown-body .pl-k{color:#cf222e}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#0a3069}.markdown-body .pl-smw,.markdown-body .pl-v{color:#953800}.markdown-body .pl-bu{color:#82071e}.markdown-body .pl-ii{color:#f6f8fa;background-color:#82071e}.markdown-body .pl-c2{color:#f6f8fa;background-color:#cf222e}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#116329}.markdown-body .pl-ml{color:#3b2300}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#0550ae}.markdown-body .pl-mi{font-style:italic;color:#24292f}.markdown-body .pl-mb{font-weight:700;color:#24292f}.markdown-body .pl-md{color:#82071e;background-color:#ffebe9}.markdown-body .pl-mi1{color:#116329;background-color:#dafbe1}.markdown-body .pl-mc{color:#953800;background-color:#ffd8b5}.markdown-body .pl-mi2{color:#eaeef2;background-color:#0550ae}.markdown-body .pl-mdr{font-weight:700;color:#8250df}.markdown-body .pl-ba{color:#57606a}.markdown-body .pl-sg{color:#8c959f}.markdown-body .pl-corl{text-decoration:underline;color:#0a3069}.markdown-body g-emoji{display:inline-block;min-width:1ch;font-family:"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:1em;font-style:normal!important;font-weight:400;line-height:1;vertical-align:-.075em}.markdown-body g-emoji img{width:1em;height:1em}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item label{font-weight:400}.markdown-body .task-list-item.enabled label{cursor:pointer}.markdown-body
      .body { margin:0; background-color:#f6f8fa; }
      .markdown-body {
        box-sizing: border-box;
        max-width: 860px;
        margin: 60px auto;
        padding: 40px;
        background-color: #ffffff;
        box-shadow: 0 0 20px rgba(0,0,0,0.05);
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <article class="markdown-body">
      <h1
      id="turn-based-strategy-framework-v40---unity-documentation">Turn-Based
      Strategy Framework v4.0.2 - Unity Documentation</h1>
      <h2 id="1-introduction">1. Introduction</h2>
      <p>The Turn-Based Strategy Framework (TBSF) is a flexible and
      customizable toolkit for developing turn-based strategy games. It
      handles essential mechanics like grid-based movement, turn
      management, unit behaviour, and AI decision-making, while offering
      the flexibility to extend and customize these systems to fit your
      project’s needs. With support for both Unity and Godot, TBSF gives
      developers the freedom to choose their preferred engine without
      sacrificing functionality. Proven in released games and supported
      by an active Discord community, TBSF offers reliability for
      professional projects along with a friendly space for advice,
      feedback, and collaboration.</p>
      <h2 id="core-features">Core Features</h2>
      <ul>
      <li>Covers basic turn-based mechanics, like map generation,
      pathfinding, combat, and special abilities.</li>
      <li>Works with both hexagonal and square grids, in 2D and 3D
      environments.</li>
      <li>Supports gameplay for both human and AI opponents.</li>
      <li>Comes with built-in online multiplayer functionality.</li>
      <li>Used in real-world projects with an active community for help
      and feedback.</li>
      </ul>
      <h2 id="who-should-use-this-framework">Who Should Use This
      Framework?</h2>
      <p>The Framework is designed for Unity and Godot developers who
      want to save time on implementing basic turn-based mechanics and
      focus on quickly prototyping and building gameplay features. It
      handles the core systems so you can concentrate on what makes your
      game unique. It’s suitable for both experts and beginners with
      basic C# programming skills, offering flexibility for experienced
      developers while remaining accessible to those just starting
      out.</p>
      <h2 id="what-you-will-find-in-this-documentation">What You Will
      Find in This Documentation</h2>
      <p>This documentation provides a thorough guide to using the TBS
      Framework, from initial setup to advanced customization. You will
      find:</p>
      <ul>
      <li>Step-by-step instructions for setting up your project in Unity
      or Godot.</li>
      <li>In-depth explanations of core concepts such as cells, units,
      grids, and player interactions.</li>
      <li>Guidance on customizing and extending the framework to suit
      your specific game design needs.</li>
      <li>A detailed look at the AI system, along with strategies for
      creating intelligent and adaptable opponents.</li>
      <li>Setting up online play</li>
      <li>Tutorials, examples, and best practices to help you get the
      most out of the framework.</li>
      </ul>
      <p>The goal of this documentation is to equip you with the
      knowledge needed to efficiently build and expand your turn-based
      strategy game, using a powerful and flexible framework that adapts
      to your creative vision.</p>
      <h2 id="table-of-contents">Table Of Contents</h2>
      <ul>
      <li><a href="#1-introduction">1. Introduction</a>
      <ul>
      <li><a href="#core-features">Core Features</a></li>
      <li><a href="#who-should-use-this-framework">Who Should Use This
      Framework?</a></li>
      <li><a href="#what-you-will-find-in-this-documentation">What You
      Will Find in This Documentation</a></li>
      </ul></li>
      <li><a href="#2-getting-started">2. Getting Started</a>
      <ul>
      <li><a href="#prerequisites">Prerequisites</a></li>
      <li><a href="#installation-and-setup">Installation and
      Setup</a></li>
      <li><a href="#project-structure-overview">Project Structure
      Overview</a></li>
      <li><a href="#running-samples">Running samples</a></li>
      </ul></li>
      <li><a href="#3-scene-structure">3. Scene Structure</a>
      <ul>
      <li><a href="#scene-hierarchy-overview">Scene Hierarchy
      Overview</a></li>
      </ul></li>
      <li><a href="#4-creating-a-scene">4. Creating a Scene</a>
      <ul>
      <li><a href="#what-is-a-cell">What is a Cell?</a></li>
      <li><a href="#what-is-a-unit">What is a Unit?</a></li>
      <li><a href="#introduction-to-the-gridhelper">Introduction to the
      GridHelper</a></li>
      <li><a href="#grid-generation-fields-and-parameters">Grid
      Generation Fields and Parameters</a></li>
      <li><a href="#working-with-the-generated-scene">Working with the
      Generated Scene</a></li>
      <li><a href="#tile-painter">Tile Painter</a></li>
      <li><a href="#unit-painter">Unit Painter</a></li>
      <li><a href="#using-unitys-tile-palette-with-custom-brushes">Using
      Unity's Tile Palette with Custom Brushes</a></li>
      </ul></li>
      <li><a href="#5-customization">5. Customization</a>
      <ul>
      <li><a href="#cell-customization">Cell Customization</a></li>
      <li><a href="#unit-customization">Unit Customization</a></li>
      <li><a href="#highlighter-system">Highlighter System</a></li>
      </ul></li>
      <li><a href="#6-unit-ability-system">6. Unit Ability System</a>
      <ul>
      <li><a href="#overview-of-ability-class-methods">Overview of
      Ability Class Methods</a></li>
      <li><a href="#executing-abilities">Executing Abilities</a></li>
      <li><a href="#setting-up-abilities">Setting up Abilities</a></li>
      <li><a href="#sample-abilities">Sample Abilities</a></li>
      </ul></li>
      <li><a href="#7-ai-system">7. AI System</a>
      <ul>
      <li><a href="#aiplayer-and-unit-selection">AIPlayer and Unit
      Selection</a></li>
      <li><a href="#behaviour-trees-and-nodes">Behaviour Trees and
      Nodes</a></li>
      </ul></li>
      <li><a href="#8-game-state-management">8. Game State
      Management</a>
      <ul>
      <li><a href="#user-interaction">User Interaction</a></li>
      <li><a href="#turn-management">Turn Management</a></li>
      <li><a href="#ending-the-game">Ending the Game</a></li>
      </ul></li>
      <li><a href="#9-online-multiplayer">9. Online Multiplayer</a>
      <ul>
      <li><a href="#architecture">Architecture</a></li>
      <li><a href="#scene-setup">Scene Setup</a></li>
      <li><a href="#network-gui">Network GUI</a></li>
      <li><a href="#game-state-synchronization">Game State
      Synchronization</a></li>
      <li><a href="#additional-actions">Additional Actions</a></li>
      <li><a href="#nakama-integration">Nakama Integration</a></li>
      </ul></li>
      <li><a href="#9-tutorial">10. Tutorial</a>
      <ul>
      <li><a href="#cell-template">Cell Template</a></li>
      <li><a
      href="#generating-the-grid-using-the-grid-helper">Generating the
      Grid Using the Grid Helper</a></li>
      <li><a href="#creating-an-obstacle-cell">Creating an Obstacle
      Cell</a></li>
      <li><a href="#painting-obstacles-onto-the-grid">Painting Obstacles
      onto the Grid</a></li>
      <li><a href="#creating-the-unit-template">Creating the Unit
      Template</a></li>
      </ul></li>
      <li><a
      href="#11-beyond-the-basics-pushing-the-limits-of-the-turn-based-strategy-framework">11.
      Beyond the Basics: Pushing the Limits of the Turn-Based Strategy
      Framework</a>
      <ul>
      <li><a href="#1-using-unity-tilemap-system-for-maps">1. Using
      Unity Tilemap System for maps</a></li>
      <li><a href="#2-porting-to-other-engines">2. Porting to other
      engines</a></li>
      </ul></li>
      <li><a href="#12-support">12. Support</a></li>
      <li><a href="#13-conclusion">13. Conclusion</a></li>
      </ul>
      <h2 id="2-getting-started">2. Getting Started</h2>
      <h3 id="prerequisites">Prerequisites</h3>
      <p>The Framework was designed to be used with Unity 2023 and
      above</p>
      <h3 id="installation-and-setup">Installation and Setup</h3>
      <p>Follow these steps to import the Turn Based Strategy Framework
      into your project:</p>
      <ol type="1">
      <li><p>Navigate to the Framework page on the Unity Asset Store at
      <a href="https://u3d.as/mfd">https://u3d.as/mfd</a></p></li>
      <li><p>Press the "Open in Unity" button</p></li>
      <li><p>In the Package Manager window, press the "Download" button
      and then "Import" button</p></li>
      <li><p>In the Import dialog window, press the "Next" button</p>
      <p><strong>OR</strong></p></li>
      <li><p>Open Package Manager in the Unity Editor</p></li>
      <li><p>Search for the "Turn Based Strategy Framework"</p></li>
      <li><p>In the Package Manager window, press the "Download" button
      and then "Import" button</p></li>
      <li><p>In the Import dialog window, press the "Next"
      button</p></li>
      </ol>
      <h3 id="project-structure-overview">Project Structure
      Overview</h3>
      <p>The TBS Framework is organized to be clear and easy to use.
      This page describes the main parts of the project and how they are
      set up.</p>
      <ul>
      <li>The <strong><code>Editor/</code></strong> folder contains
      editor-specific scripts and tools, like the Grid Helper.</li>
      <li>The <strong><code>Examples/</code></strong> folder contains
      sample scenes, assets, and code demonstrating framework usage,
      including the tutorial.</li>
      <li>The <strong><code>External/tbsf-common/</code></strong> folder
      houses the core framework logic shared across engines.</li>
      <li>Finally, the <strong><code>Scripts/</code></strong> folder
      contains Unity-specific implementations of framework components
      and game logic.</li>
      </ul>
      <pre><code>TBSF/
├───Editor                                  # Editor-specific scripts and tools, like the Grid Helper
├───Examples                                # Sample scenes, assets, and code demonstrating framework usage, including the tutorial
├───External
│   └───tbsf-common                         # Core framework logic shared across engines
└───Scripts                                 # Unity-specific implementations of framework components and game logic</code></pre>
      <div align="center"><i>TBSF project structure</i></div>

      <h3 id="running-samples">Running samples</h3>
      <p>The best way to get familiar with the framework is to study the
      sample demos provided. These examples showcase various features
      and configurations, helping you understand how to integrate and
      utilize the framework in your own projects.</p>
      <p>The <code>Examples</code> folder contains several types of
      demos:</p>
      <ul>
      <li><strong>Clash of Heroes Demo</strong>: A comprehensive
      demonstration showcasing many framework features working
      together.</li>
      <li><strong>Legacy Demos</strong>: Simpler demonstrations from
      previous versions of the framework, still valuable for
      understanding core concepts.</li>
      <li><strong>Tilemap Demo</strong>: A demo showcasing an
      alternative grid setup using Unity's Tilemap system.</li>
      </ul>
      <p>To run these examples and quickly get familiar with the
      framework:</p>
      <ol type="1">
      <li>Navigate to any demo in the <code>Examples/</code> folder in
      your Unity project's Project window.</li>
      <li>Double-click on any of the scene files to open them in the
      Unity Editor.</li>
      <li>Press the <strong>Play</strong> button in the Unity Editor to
      start the scene and interact with the demo.</li>
      </ol>
      <h2 id="3-scene-structure">3. Scene Structure</h2>
      <h3 id="scene-hierarchy-overview">Scene Hierarchy Overview</h3>
      <p>This section covers the structure of a bare-bones scene in the
      Turn-Based Strategy Framework. The following hierarchy represents
      the minimal setup required for a playable scene. More complex
      levels with custom game mechanics might include additional
      components.</p>
      <pre><code>Root
│
├── CellManager/          // RegularCellManager.cs, assigned to Grid Controller
│   └── Cells
│
├── UnitManager/          // UnityUnitManager.cs, assigned to Grid Controller
│   └── Units
│
├── PlayerManager/        // UnityPlayerManager.cs, assigned to Grid Controller
│   └── Players
│
├── GridController/       // UnityGridController.cs 
│   └── TurnResolver      // Assigned to Grid Controller
│
├── GUIController/        // GUIController.cs
│
├── Camera
│   └── Physics Raycaster // For mouse interaction with the game
│
└── GameEndConditions/
    └── Conditions</code></pre>
      <div align="center"><i>Basic scene structure</i></div>

      <ul>
      <li><p><strong>CellManager</strong>:<br />
      The <code>CellManager</code> handles all cells within the grid. It
      allows retrieval of specific cells and marking cells for visual
      feedback (such as highlighting selected or reachable cells). All
      cells in the game are added as children of the
      <code>CellManager</code> game object.</p></li>
      <li><p><strong>UnitManager</strong>:<br />
      The <code>UnitManager</code> oversees all units, enabling unit
      addition and retrieval of friendly or enemy units based on the
      player. It also handles visual indicators like marking units as
      selected, finished, or attacking. All units in the game are added
      as children of the <code>UnitManager</code> game object.</p></li>
      <li><p><strong>PlayerManager</strong>:<br />
      The <code>PlayerManager</code> manages all players in the game,
      offering methods to retrieve players and identify them by player
      number. All player game objects are added as children of the
      <code>PlayerManager</code> game object.</p></li>
      <li><p><strong>GridController</strong>:<br />
      The <code>GridController</code> is the core of the grid-based
      gameplay. It orchestrates interactions between cells, units, and
      players. It also manages key game functions like turn progression,
      ensuring that each player gets a turn and that the game moves
      smoothly from one turn to the next. The
      <code>GridController</code> references the
      <code>TurnResolver</code> to manage turn transitions and interacts
      with the managers (<code>CellManager</code>,
      <code>UnitManager</code>, <code>PlayerManager</code>) to keep
      track of the game's state.</p></li>
      <li><p><strong>TurnResolver</strong>:<br />
      This component handles the progression of turns in the game. It
      determines which player goes next and manages the transition
      between player turns. The <code>TurnResolver</code> can be
      customized to fit specific game rules, allowing developers to
      implement custom turn mechanics.</p></li>
      <li><p><strong>GUI Controller</strong>:<br />
      A basic component that handles ending player's turn at the press
      of a button on the keyboard.</p></li>
      <li><p><strong>GameEndConditions</strong>:<br />
      This component defines the victory or loss conditions for the
      game. By default, the <code>DominationCondition</code> is used,
      which checks if only one player has remaining units, ending the
      game if true. Custom conditions can be added to tailor the game’s
      end state to specific rules, like capturing objectives or
      achieving a score threshold.</p></li>
      </ul>
      <h2 id="4-creating-a-scene">4. Creating a Scene</h2>
      <p>Before proceeding with grid generation, it’s essential to
      understand two core concepts: <strong>cells</strong> and
      <strong>units</strong>. These are the fundamental building blocks
      of your game’s grid. In the next sections, we’ll explain what
      cells and units are, and how they interact with the grid to create
      engaging turn-based strategy gameplay.</p>
      <h3 id="what-is-a-cell">What is a Cell?</h3>
      <p>In the Turn-Based Strategy Framework, a <strong>cell</strong>
      is the fundamental building block of the game’s grid. Each cell
      represents a tile on the map, and together, cells form the entire
      game board where the action takes place. The Framework provides
      two ready-to-use implementations of the abstract
      <code>Cell.cs</code> class—<code>Hexagon.cs</code> for hexagonal
      grids and <code>Square.cs</code> for square grids.</p>
      <p>A cell is a GameObject with one of these scripts, or a custom
      script derived from <code>Cell.cs</code>, attached to it. A
      typical cell includes a 3D model or sprite and a
      <strong>Collider</strong> component for handling mouse
      interactions. To enable interaction, you'll use Unity's Event
      System with a <strong>Physics Raycaster</strong> on the camera,
      and the cell script implements the
      <code>IPointerClickHandler</code>,
      <code>IPointerEnterHandler</code>, and
      <code>IPointerExitHandler</code> interfaces. Finally, a cell has
      functions that define its appearance in different game states
      (e.g., selected, reachable, or part of a path). To complete the
      cell setup, these functions should be assigned to appropriate
      fields in the Cell script. If they’re not, the cell will provide
      no visual feedback for player actions. The project includes
      several predefined highlighters that can be used with both cells
      and units. These will be discussed in the customization
      chapter.</p>
      <blockquote>
      <p>Although this is the case for the default setup of a cell,
      Cells don’t necessarily have to be GameObjects—see Chapter 10 for
      more advanced approaches like tilemap-backed virtual cells.</p>
      </blockquote>
      <p>Each cell has several important properties: its
      <strong>GridCoordinates</strong> define its position on the grid,
      while <strong>WorldPosition</strong> refers to its location in the
      3D game world. A cell can also be marked as
      <strong>IsTaken</strong>, indicating whether it’s occupied, and it
      keeps track of units within it through
      <strong>CurrentUnits</strong>, a list of any occupying units.
      Additionally, <strong>MovementCost</strong> determines the cost of
      moving to the cell.</p>
      <pre><code>Root (GameObject)                        // `Hexagon.cs`, `Square.cs`, or a custom derived script attached
│
├── Collider                             // Contains a Collider component (e.g., Box Collider, Mesh Collider)
│
├── MeshRenderer / SpriteRenderer        // The model or sprite representing the cell
│
└── Highlighters (GameObject)            // Container for visual feedback for different states, contains implementations of `Highlighter.cs`
    ├── UnMarkHighlighter                // GameObject with a Highlighter script to restore default appearance
    ├── SelectedHighlighter              // GameObject with a Highlighter script for selection
    ├── ReachableHighlighter             // GameObject with a Highlighter script for reachable cells
    └── PathHighlighter                  // GameObject with a Highlighter script for movement paths</code></pre>
      <div align="center"><i>Basic structure of a typical cell</i></div>

      <h3 id="what-is-a-unit">What is a Unit?</h3>
      <p>In the Turn-Based Strategy Framework, a <strong>unit</strong>
      represents an entity that players control or interact with on the
      grid. Units are the main actors in gameplay, capable of moving
      between cells, engaging in combat, and using special abilities.
      The framework allows for customization of units to support
      different gameplay mechanics.</p>
      <p>Several fields define a unit's capabilities:
      <strong>ActionPoints</strong> determine how many actions a unit
      can perform per turn, while <strong>MovementPoints</strong> define
      how far the unit can move. Units also have
      <strong>Health</strong>, which affects their survivability,
      <strong>AttackRange</strong>, which determines their attack
      distance, and <strong>AttackFactor</strong> and
      <strong>DefenceFactor</strong>, which influence how much damage
      they deal and how much they can defend against.</p>
      <p>A Unit is a GameObject with the <code>Unit.cs</code>, or
      derived, script attached to it. A typical unit GameObject
      structure includes a model or sprite representing the unit and a
      <strong>Collider</strong> component for handling interactions. To
      enable interaction, you'll use Unity's Event System with a
      <strong>Physics Raycaster</strong> on the camera, and the unit
      script implements the <code>IPointerClickHandler</code>,
      <code>IPointerEnterHandler</code>, and
      <code>IPointerExitHandler</code> interfaces. Units also include
      visual indicators for different states, such as being selected,
      engaged in combat, or marked as a target. To complete the unit
      setup, these functions should be assigned to the relevant fields
      in the <code>Unit</code> script to ensure visual feedback in
      different game states.</p>
      <p>Apart from that, a unit typically has two default
      abilities—<strong>MoveAbility</strong> and
      <strong>AttackAbility</strong>. These abilities are assigned to
      the <code>BaseAbilities</code> field on the Unit script.
      <strong>Base abilities</strong> are the abilities that get
      activated by default when a unit is selected, allowing it to move
      across the grid or attack other units. If no ability is assigned
      to the <code>BaseAbilities</code> field, the unit will not be able
      to take any action.</p>
      <p>Finally, each unit has a "brain" GameObject that holds a
      <strong>BehaviourTreeResource</strong>. This component lets the AI
      control the unit's actions and decision-making. The project
      includes a simple <code>RegularBehaviourTree</code> you can use,
      or you can set up your own custom trees (covered in a later
      chapter). <code>BehaviourTreeResource</code> should be assigned to
      <code>Unit._behaviourTreeNode</code> in the editor.</p>
      <pre><code>Root (GameObject)                        // `Unit.cs` or a custom derived script attached
│
├── Collider                             // Contains a Collider component (e.g., Box Collider, Mesh Collider)
│
├── MeshRenderer / SpriteRenderer        // The model or sprite representing the unit
│
├── Highlighters (GameObject)            // Container for visual feedback for different states
│   ├── MarkAsSelectedHighlighter        // GameObject with a Highlighter script for selected state
│   ├── MarkAsFriendlyHighlighter        // GameObject with a Highlighter script for friendly state
│   ├── MarkAsFinishedHighlighter        // GameObject with a Highlighter script for finished state
│   ├── MarkAsReachableEnemyHighlighter  // GameObject with a Highlighter script for reachable enemy state
│   └── MarkAsAttackingHighlighter       // GameObject with a Highlighter script for attacking state
│                      
├── MoveAbility (GameObject)             // GameObject with MoveAbility script
├── AttackAbility (GameObject)           // GameObject with AttackAbility script
│
└── Brain (GameObject)                   // BehaviourTreeNode script/component used by the AI to control the unit</code></pre>
      <div align="center"><i>Basic structure of a typical unit</i></div>

      <h3 id="introduction-to-the-gridhelper">Introduction to the
      GridHelper</h3>
      <p>The <strong>GridHelper</strong> is a tool in the Turn-Based
      Strategy Framework that automates the creation of grid-based maps.
      It allows you to set up a grid, assign cells, and place units on
      it, simplifying the process of building your game’s levels.</p>
      <p>To begin using the <strong>GridHelper</strong> for generating
      grids in Unity, simply select <strong>Window &gt; Grid
      Helper</strong> in the Unity Editor. The Grid Helper window will
      appear.</p>
      <h3 id="grid-generation-fields-and-parameters">Grid Generation
      Fields and Parameters</h3>
      <p>The <strong>GridHelper</strong> provides several fields that
      allow you to customize your grid’s size, shape, and the types of
      cells and units it will contain. Below are the parameters
      available for grid generation:</p>
      <ul>
      <li><p><strong>Human Players No</strong>:<br />
      This field allows you to specify the number of human players in
      the game. The default value is <code>2</code>, but you can adjust
      it depending on your game’s requirements.</p></li>
      <li><p><strong>AI Players No</strong>:<br />
      Here, you can set the number of AI-controlled players that will
      participate in the game.</p>
      <p>The number of players can be changed after the grid is
      generated by adding or removing player nodes from the
      <strong>PlayerManager</strong> node.</p></li>
      <li><p><strong>Plane</strong>: Indicates whether the map should be
      generated along the XY (for 2D maps) or XZ plane (for 3D
      maps)</p></li>
      <li><p><strong>Generator</strong>: Select the generator for either
      Square based maps or Hex based maps</p></li>
      <li><p><strong>Width and Height</strong>:<br />
      These fields determine the dimensions of the grid. You can set
      both the <strong>width</strong> (number of columns) and
      <strong>height</strong> (number of rows) to customize the size of
      your map.</p></li>
      <li><p><strong>Cell Prefab</strong>:<br />
      This field allows you to assign a specific cell prefab to be used
      for generating the grid.</p></li>
      </ul>
      <p>To generate the map, do the following:</p>
      <ul>
      <li>Create a new scene using <strong>File &gt; New
      Scene</strong></li>
      <li>Fill in the Grid Helper parameters</li>
      <li>Click the <strong>Generate Scene</strong> button</li>
      </ul>
      <p>The script will automatically create all necessary components
      described in the previous chapter, including the
      <strong>CellManager</strong>, <strong>PlayerManager</strong>, and
      <strong>UnitManager</strong>. It will also ensure that a main
      camera is placed in the scene and properly aligned to show the
      grid. Additionally, the script will add lighting and a basic GUI
      controller for handling turn transitions.</p>
      <h3 id="working-with-the-generated-scene">Working with the
      Generated Scene</h3>
      <p>Once the grid is generated, you can make adjustments to the
      scene using two primary methods for map editing: the dedicated
      Painters within the Grid Helper, and Unity's Tile Palette with
      custom brushes.</p>
      <ul>
      <li><p><strong>Editing the Map</strong>:</p>
      <ul>
      <li><strong>Using Painters (Legacy)</strong>: The <strong>Tile
      Painter</strong> is a legacy feature that allows you to customize
      the grid by applying different cell types, and the <strong>Unit
      Painter</strong> is used to place and assign units.
      <strong>Note:</strong> With painters, you can only paint over
      cells that have already been generated by the Grid Helper.</li>
      <li><strong>Using Unity's Tile Palette (New)</strong>: For a more
      integrated workflow, you can use Unity's <strong>Tile
      Palette</strong> with custom <code>CellBrush</code> and
      <code>UnitBrush</code> assets to paint cells and units directly
      onto the grid. A key advantage of this new method is the ability
      to add cells arbitrarily, not just replace existing ones.</li>
      </ul></li>
      <li><p><strong>Managing Players</strong>: Players are managed by
      adding or removing player GameObjects under the
      <strong>PlayerManager</strong> GameObject. Ensure each player
      GameObject is properly configured with an appropriate player
      number.</p></li>
      </ul>
      <h3 id="tile-painter">Tile Painter</h3>
      <p>The <strong>Tile Painter</strong> is a tool within the
      <strong>GridHelper</strong> that allows you to modify the
      generated grid by applying different cell types to specific
      locations. This can be useful for customizing parts of the map,
      such as designating obstacles or other terrain features.</p>
      <p>To use the Tile Painter:</p>
      <ol type="1">
      <li><strong>Assign a Cell Prefab</strong>: Assign the cell prefab
      you want to paint with to the <strong>Cell Prefab</strong> field
      in the <strong>GridHelper</strong> window.</li>
      <li><strong>Enter Tile Edit Mode</strong>: Click the <strong>Enter
      Tile Edit Mode</strong> button. This activates the painting
      mode.</li>
      <li><strong>Painting Cells</strong>: While in tile edit mode,
      click on any cell in the grid to replace it with the selected cell
      prefab. The new cell will take the place of the existing one.</li>
      <li><strong>Exit Tile Edit Mode</strong>: Once you’ve finished
      making changes, click the <strong>Exit Tile Edit Mode</strong>
      button to return to the normal scene editing mode.</li>
      </ol>
      <h3 id="unit-painter">Unit Painter</h3>
      <p>The <strong>Unit Painter</strong> allows you to place and
      assign units to specific players on the grid. This tool is helpful
      for setting up the initial state of the game, such as positioning
      starting units for each player or placing neutral units.</p>
      <p>To use the Unit Painter:</p>
      <ol type="1">
      <li><strong>Assign a Unit Prefab</strong>: Assign the unit prefab
      to the <strong>Unit Prefab</strong> field in the
      <strong>GridHelper</strong> window.</li>
      <li><strong>Assign Player Number</strong>: Set the <strong>Player
      Number</strong> field to the player you want to assign the unit
      to. This number corresponds to the player GameObject in the
      <strong>PlayerManager</strong>.</li>
      <li><strong>Enter Unit Edit Mode</strong>: Click the <strong>Enter
      Unit Edit Mode</strong> button to activate unit placement
      mode.</li>
      <li><strong>Placing Units</strong>: While in unit edit mode, click
      on a cell in the grid to place a unit. The unit will be positioned
      on the selected cell and assigned to the player you
      specified.</li>
      <li><strong>Exit Unit Edit Mode</strong>: After placing the units,
      click the <strong>Exit Unit Edit Mode</strong> button to return to
      the normal scene editing mode.</li>
      </ol>
      <h3 id="using-unitys-tile-palette-with-custom-brushes">Using
      Unity's Tile Palette with Custom Brushes</h3>
      <p>The framework provides custom brushes (<code>CellBrush</code>
      and <code>UnitBrush</code>) to integrate map editing directly with
      Unity's Tile Palette system. This offers a more flexible and
      familiar workflow for Unity developers.</p>
      <p>To use the custom brushes with the Tile Palette:</p>
      <ol type="1">
      <li><strong>Select the Grid GameObject</strong>: In your scene's
      Hierarchy window, select the <code>Grid</code> GameObject (this is
      the GameObject where the <code>GridController</code> script is
      attached).</li>
      <li><strong>Open the Tile Palette Window</strong>: Navigate to
      <strong>Window &gt; 2D &gt; Tile Palette</strong> in the Unity
      Editor.</li>
      <li><strong>Select a Custom Brush</strong>: In the Tile Palette
      window, select either the <code>CellBrush</code> or
      <code>UnitBrush</code> from the dropdown. These are custom brush
      assets provided with the framework.</li>
      <li><strong>Assign Prefabs</strong>:
      <ul>
      <li>If using <code>CellBrush</code>, assign your desired cell
      prefab to the <strong>Cell Prefab</strong> field on the brush
      inspector.</li>
      <li>If using <code>UnitBrush</code>, assign your desired unit
      prefab to the <strong>Unit Prefab</strong> field on the brush
      inspector.</li>
      <li><em>Note</em>: The <code>UnitBrush</code> also has a
      <strong>Player Number</strong> field to assign the player
      ownership to the units you paint.</li>
      </ul></li>
      <li><strong>Configure Brush Parameters</strong>: Both custom
      brushes have two important parameters:
      <ul>
      <li><strong>Offset</strong>: This parameter changes the position
      of spawned cells/units relative to the grid cell's center. Adjust
      this to align your prefabs correctly.</li>
      <li><strong>Is 2D Map</strong>: Ensure this boolean parameter is
      set correctly based on whether your grid is a 2D or 3D map.</li>
      </ul></li>
      <li><strong>Paint on the Scene</strong>: With the correct brush,
      prefab, and parameters set, use the Tile Palette interface (e.g.,
      paint tool, erase tool, fill tool) to paint cells or place units
      directly onto your grid in the Scene view.</li>
      </ol>
      <h2 id="5-customization">5. Customization</h2>
      <p>In the Turn-Based Strategy Framework, both cells and units can
      be customized in two main areas: <strong>visuals</strong> and
      <strong>behaviour</strong>. Below, we break down how these aspects
      can be modified to fit your game’s needs.</p>
      <h3 id="cell-customization">Cell Customization</h3>
      <h4 id="cell-visuals">Cell Visuals</h4>
      <p>Cells use a series of virtual <code>MarkAs...</code> methods to
      control how they are visually highlighted in different game
      states. These methods include:</p>
      <ul>
      <li><code>MarkAsHighlighted()</code>: Highlights the cell to
      indicate it is currently selected.</li>
      <li><code>MarkAsReachable()</code>: Highlights the cell to show
      that it is reachable for movement.</li>
      <li><code>MarkAsPath()</code>: Marks the cell as part of a
      calculated movement path, visually indicating the path a unit will
      take.</li>
      <li><code>UnMark()</code>: Restores the cell to its default
      appearance, removing any visual highlights or markings.</li>
      </ul>
      <p>Each of these methods is backed by a
      <strong>Highlighter</strong> object, which encapsulates the actual
      function used for highlighting. The user can customize the
      appearance of cells in two ways:</p>
      <ol type="1">
      <li><strong>Override the virtual methods</strong>: Legacy, less
      flexible method that allows for complete control over how the cell
      behaves visually.</li>
      <li><strong>Assign predefined highlighter objects</strong>: The
      framework provides several reusable <strong>Highlighter</strong>
      objects that can be assigned to the relevant fields.</li>
      </ol>
      <p>The highlighter system is flexible and shared between both
      units and cells, making it easy to reuse or modify the visual
      feedback across both.</p>
      <h4 id="cell-behaviour">Cell Behaviour</h4>
      <p>For cells, behaviour customization typically revolves around
      pathfinding. The following methods control how the cell interacts
      with other cells in the grid:</p>
      <ul>
      <li><strong>GetDistance(ICell otherCell)</strong>: Determines the
      distance between the current cell and another cell.</li>
      <li><strong>GetNeighbours(ICellManager cellManager)</strong>:
      Retrieves the neighboring cells based on the current grid
      configuration.</li>
      </ul>
      <p>The default cell implementations, <code>Square.cs</code> and
      <code>Hexagon.cs</code> has both of these methods implemented.</p>
      <h3 id="unit-customization">Unit Customization</h3>
      <h4 id="unit-visuals">Unit Visuals</h4>
      <p>Similar to cells, units rely on virtual <code>MarkAs...</code>
      methods to control their visual feedback in different states:</p>
      <ul>
      <li><code>MarkAsSelected()</code>: Highlights the unit to indicate
      it has been selected by the player for actions.</li>
      <li><code>MarkAsFriendly()</code>: Highlights the unit as
      friendly, to distinguish between allied and enemy units.</li>
      <li><code>MarkAsFinished()</code>: Marks the unit as having
      completed all its actions for the turn.</li>
      <li><code>MarkAsReachableEnemy()</code>: Highlights enemy units
      that are within range and can be targeted or attacked.</li>
      <li><code>MarkAsAttacking()</code>: Visually indicates that the
      unit is performing an attack.</li>
      <li><code>UnMark()</code>: Removes all highlights from the unit,
      restoring its default appearance.</li>
      </ul>
      <p>These methods are also backed by <strong>Highlighter</strong>
      objects, providing the same flexibility for visual customization.
      As with cells, users can either override these methods or assign
      predefined highlighters to the corresponding fields.</p>
      <h4 id="unit-behaviour">Unit Behaviour</h4>
      <p>Units have more extensive behavioral customization options
      compared to cells, as they manage movement, combat, and
      interactions with the grid. Here are the key virtual methods you
      can customize:</p>
      <ul>
      <li><strong>Initialize()</strong>: This method is called when the
      unit is created and can be used to set up initial state.</li>
      <li><strong>OnTurnStart(GridController gridController)</strong>:
      Triggered at the beginning of the unit’s turn.</li>
      <li><strong>OnTurnEnd(GridController gridController)</strong>:
      Triggered at the end of the unit’s turn.</li>
      <li><strong>OnUnitSelected(GridController
      gridController)</strong>: Handles logic when a unit is selected by
      the player.</li>
      <li><strong>OnUnitDeselected(GridController
      gridController)</strong>: Handles logic when a unit is
      deselected.</li>
      <li><strong>OnDestroyed(GridController gridController)</strong>:
      Called when unit is destroyed, typically when health drops to
      0.</li>
      </ul>
      <p><strong>Movement-related methods</strong>: These three
      high-level methods used to define how the unit moves. Easy to use
      and should cover most of the use cases</p>
      <ul>
      <li><strong>IsCellMovableTo(ICell cell)</strong>: Determines if
      the unit can move to a specific cell.</li>
      <li><strong>IsCellTraversable(ICell source, ICell
      destination)</strong>: Checks whether a cell is traversable by the
      unit.</li>
      <li><strong>GetMovementCost(ICell source, ICell
      destination)</strong>: Determines the movement cost between the
      two cells. By default, the <code>MovementCost</code> of the
      destination cell is considered.</li>
      </ul>
      <p>These two low-level methods allow for more precise control of
      unit movement. They should be used when the other three methods
      are not expressive enough.</p>
      <ul>
      <li><strong>GetAvailableDestinations(IEnumerable<ICell>
      cells)</strong>: Provides a list of available destinations for the
      unit.</li>
      <li><strong>GetGraphEdges(ICellManager cellManager)</strong>:
      Returns the graph representation of the movement grid, used by the
      pathfinding algorithm.</li>
      </ul>
      <p><strong>Combat-related methods</strong>:</p>
      <ul>
      <li><strong>IsUnitAttackable(IUnit otherUnit, ICell otherUnitCell,
      ICell attackSourceCell)</strong>: Determines if another unit is
      attackable.</li>
      <li><strong>CalculateDamageDealt(IUnit aggressor)</strong>:
      Calculates the damage dealt when attacking another unit.</li>
      <li><strong>CalculateDamageTaken(IUnit aggressor)</strong>:
      Calculates the damage taken when attacked by another unit.</li>
      </ul>
      <p>In addition to the methods above, units use a flexible ability
      system and a behaviour tree-based AI, which will be discussed in
      separate chapters.</p>
      <h3 id="highlighter-system">Highlighter System</h3>
      <p>The <strong>Highlighter</strong> system in the Turn-Based
      Strategy Framework offers a flexible way to manage visual feedback
      for both units and cells. Highlighters are reusable components
      that define how game objects visually respond to interactions like
      selection, movement, or combat.</p>
      <p>Both <strong>Cell</strong> and <strong>Unit</strong> scripts
      contain a set of <code>MarkAs...Fn</code> fields to trigger
      various visual states (e.g., selected, reachable, or attacking).
      To use the highlighter system, simply assign a
      <strong>GameObject</strong> with a script derived from
      <strong>Highlighter</strong> to these fields. This setup is
      typically done by adding highlighter scripts to the prefab and
      linking them to the corresponding field. Multiple highlighters can
      be applied to a single field to create complex effects. You can
      create custom effects by extending the
      <strong>Highlighter</strong> class and overriding the
      <code>Apply</code> method, or use one of the predefined effects
      included in the project:</p>
      <ul>
      <li><p><strong>DebugHighlighter</strong> A simple highlighter that
      prints a message to the console when applied. Useful for testing
      and debugging without any visual effects.</p></li>
      <li><p><strong>SpriteRendererHighlighter</strong> This highlighter
      adjusts the color of a <code>SpriteRenderer</code> component by
      modifying its <code>color</code> property.</p></li>
      <li><p><strong>RendererHighlighter</strong> This highlighter
      changes the color of a <code>MeshRenderer</code> component by
      modifying its material's shader parameters (e.g.,
      <code>_Color</code> property).</p></li>
      <li><p><strong>GameObjectsActivatorHighlighter</strong> This
      highlighter activates or deactivates a list of specified
      GameObjects, useful for toggling complex visual effects.</p></li>
      <li><p><strong>SwayHighlighter</strong> Applies a sway animation
      to the target, moving it slightly based on its direction relative
      to another object. It's ideal for combat interactions, such as
      visually indicating a unit has been attacked or is
      defending.</p></li>
      <li><p><strong>ArrowSpritePathHighlighter</strong> Uses
      directional arrow and line sprites to represent a movement path
      visually. It's perfect for showing how a unit will move across the
      grid, with arrows pointing the way.</p></li>
      </ul>
      <p>You can find these and other highlighter scripts in the
      <code>Scripts/Highlighters/</code> folder. The highlighters listed
      above are just a few examples of the effects included in the
      project.</p>
      <h2 id="6-unit-ability-system">6. Unit Ability System</h2>
      <p>In the Turn-Based Strategy Framework,
      <strong>abilities</strong> are actions that units can perform
      during gameplay, such as moving, attacking, casting spells or
      using any other special skill. Each ability defines how a unit
      interacts with the grid and other units.</p>
      <p>Abilities are defined using the <strong>IAbility</strong>
      interface, which outlines the core methods and behaviors that all
      abilities must implement. This includes methods for initializing
      the ability, displaying visual indicators, and handling events
      such as unit or cell selection. In Unity, the <code>Ability</code>
      class implements the <code>IAbility</code> interface and it should
      be extended for implementing custom skills.</p>
      <h3 id="overview-of-ability-class-methods">Overview of Ability
      Class Methods</h3>
      <p>The <code>Ability</code> class provides several virtual methods
      that define how a unit's ability behaves during various
      interactions and game phases. Depending on your custom ability’s
      needs, you can choose to override only the methods that are
      relevant, while leaving others as they are.</p>
      <h5 id="initialization-and-cleanup">Initialization and
      Cleanup</h5>
      <ul>
      <li><p><strong><code>Initialize(GridController gridController)</code></strong>:<br />
      Called once when the ability is registered by the unit. Use this
      method to set up any initial states or prepare resources for the
      ability.</p></li>
      <li><p><strong><code>Display(GridController gridController)</code></strong>:<br />
      This method is responsible for showing the ability’s effects on
      the grid, such as highlighting cells or units. You would typically
      use this to display ranges or target areas.</p></li>
      <li><p><strong><code>CleanUp(GridController gridController)</code></strong>:<br />
      Removes any visual indicators or temporary effects left over from
      the ability’s display phase. This helps to reset the grid to its
      default state after the ability is used or canceled.</p></li>
      </ul>
      <h5 id="unit-interaction-methods">Unit Interaction Methods</h5>
      <ul>
      <li><p><strong><code>OnUnitClicked(IUnit unit, GridController gridController)</code></strong>:<br />
      Called when a unit is clicked while the ability is active. It’s
      useful for targeting specific units with abilities like attacks or
      buffs.</p></li>
      <li><p><strong><code>OnUnitHighlighted(IUnit unit, GridController gridController)</code></strong>:<br />
      Triggered when a unit is highlighted while the ability is
      selected, allowing for visual feedback when hovering over
      targetable units.</p></li>
      <li><p><strong><code>OnUnitDehighlighted(IUnit unit, GridController gridController)</code></strong>:<br />
      This method is triggered when a unit is no longer highlighted,
      typically used to remove any hover effects.</p></li>
      <li><p><strong><code>OnUnitDestroyed(GridController gridController)</code></strong>:<br />
      Called when the unit that owns this ability is destroyed. This is
      useful for cleaning up ongoing effects or stopping the ability’s
      logic.</p></li>
      </ul>
      <h5 id="cell-interaction-methods">Cell Interaction Methods</h5>
      <ul>
      <li><p><strong><code>OnCellClicked(ICell cell, GridController gridController)</code></strong>:<br />
      This method is triggered when a cell is clicked while the ability
      is active.</p></li>
      <li><p><strong><code>OnCellHighlighted(ICell cell, GridController gridController)</code></strong>:<br />
      Called when a cell is highlighted or selected, allowing you to
      provide visual feedback or logic based on cell
      interactions.</p></li>
      <li><p><strong><code>OnCellDehighlighted(ICell cell, GridController gridController)</code></strong>:<br />
      Triggered when a cell is deselected. This is often used to remove
      visual effects from previously highlighted cells.</p></li>
      </ul>
      <h5 id="turn-based-methods">Turn-based Methods</h5>
      <ul>
      <li><p><strong><code>OnTurnStart(GridController gridController)</code></strong>:<br />
      Called at the beginning of the unit’s turn.</p></li>
      <li><p><strong><code>OnTurnEnd(GridController gridController)</code></strong>:<br />
      This method is called at the end of the unit’s turn.</p></li>
      </ul>
      <h5 id="ability-selection">Ability Selection</h5>
      <ul>
      <li><p><strong><code>OnAbilitySelected(GridController gridController)</code></strong>:<br />
      Triggered when the ability is selected by the player or
      AI.</p></li>
      <li><p><strong><code>OnAbilityDeselected(GridController gridController)</code></strong>:<br />
      Called when the ability is no longer the active one.</p></li>
      </ul>
      <h5 id="other">Other</h5>
      <ul>
      <li><strong><code>CanPerform(GridController gridController)</code></strong>:<br />
      This method is used for determining whether the ability can be
      used at the current moment. It evaluates conditions like action
      points, cooldowns, or specific game rules. If true is returned,
      the ability can be performed; otherwise, it cannot. Its primary
      role is to check if the unit can perform any more actions, and if
      not, the unit is marked as finished for the turn.</li>
      </ul>
      <h3 id="executing-abilities">Executing Abilities</h3>
      <p>In the Turn-Based Strategy Framework, abilities are executed
      using a <strong>command pattern</strong>, where each ability is
      represented by a <code>Command</code> object that encapsulates the
      action to be performed. Simply speaking, the command defines what
      actually happens when the ability is executed. This pattern allows
      for flexible execution and easy undo/redo functionality if needed.
      To create custom commands, implement the <code>ICommand</code>
      interface by overriding its <code>Apply</code> and
      <code>Undo</code> methods. The project includes
      <code>MoveCommand</code> and <code>AttackCommand</code> that can
      potentially be used with custom abilities.</p>
      <p>Finally, there are two helper methods in the <code>Unit</code>
      class to execute actions: <code>HumanExecuteAbility</code> for
      human players and <code>AIExecuteAbility</code> for AI-controlled
      units. There is also a low-level <code>ExecuteAbility</code>
      method that allows defining functions to be called before and
      after the ability is executed. The code below illustrates both
      concepts:</p>
      <div class="sourceCode" id="cb5"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> AttackAbilityImpl <span class="op">:</span> IAbility<span class="op">&lt;</span>AttackCommand<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">OnUnitClicked</span><span class="op">(</span>IUnit unit<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>UnitReference<span class="op">.</span><span class="fu">ActionPoints</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> _attackableUnits<span class="op">.</span><span class="fu">Contains</span><span class="op">(</span>unit<span class="op">))</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            UnitReference<span class="op">.</span><span class="fu">HumanExecuteAbility</span><span class="op">(</span><span class="kw">new</span> <span class="fu">AttackCommand</span><span class="op">(</span>unit<span class="op">,</span> UnitReference<span class="op">.</span><span class="fu">CalculateTotalDamage</span><span class="op">(</span>unit<span class="op">)),</span> gridController<span class="op">);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*...*/</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h3 id="setting-up-abilities">Setting up Abilities</h3>
      <p>In the Turn-Based Strategy Framework, abilities can be assigned
      to units to define the actions they can perform, such as moving,
      attacking, or casting spells. The abilities that should be
      auto-selected when the unit is selected are typically attached
      directly as components to the unit's GameObject. The unit
      automatically loads these abilities during its initialization and
      assign them to the <code>BaseAbilities</code> property. When the
      unit is initialized, it calls <code>RegisterAbility</code> on each
      of the abilities to assign relevant fields, hook up events, and
      call their <code>Initialize</code> method. Only registered
      abilities will function during gameplay.</p>
      <p>It is also possible to create compound abilities that act as
      containers for other abilities. For example, a spellbook ability
      might allow the player to choose a specific spell from a list of
      options. In such cases, the compound ability must handle the
      registration of its child abilities manually.</p>
      <h3 id="sample-abilities">Sample Abilities</h3>
      <p>In this section, we will walk through the creation of two
      custom abilities to showcase key concepts in the Turn-Based
      Strategy Framework's ability system. The first ability, the
      <strong>FireballAbility</strong> is an area of effect attack that
      damages all units within given radius, the other ability, the
      <strong>CompoundAbility</strong> that allows to select a one of
      the abilities from a list, such as a spellbook or a menu.</p>
      <h4 id="the-fireballability">The FireballAbility</h4>
      <p>The FireballAbility works as follows:</p>
      <ul>
      <li>When the player hovers over a cell, all cells within a defined
      radius (set by the _radius field) are highlighted using the
      MarkAsReachable method, and all units within those cells are
      selected.</li>
      <li>If the player clicks a highlighted cell, the ability applies
      damage to all units in the selected area using the
      <code>MultipleTargetAttackCommand</code>.</li>
      <li>The ability includes handling for dehighlighting cells and
      units when they are no longer being hovered over or when the
      ability is canceled.</li>
      </ul>
      <h5 id="highlighting-cells-and-units">Highlighting Cells and
      Units</h5>
      <p>When the player hovers over a cell, the
      <code>OnCellHighlighted</code> method is called. This method
      calculates all cells within the radius using the cell’s
      <code>GetDistance</code> method and highlights them using the
      MarkAsReachable method:</p>
      <div class="sourceCode" id="cb6"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>_cellsInRange <span class="op">=</span> gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">GetDistance</span><span class="op">(</span>cell<span class="op">)</span> <span class="op">&lt;=</span> _radius<span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">MarkAsReachable</span><span class="op">(</span>_cellsInRange<span class="op">);</span></span></code></pre></div>
      <p>Simultaneously, the units within these cells are highlighted as
      potential targets, even if they are friendly:</p>
      <div class="sourceCode" id="cb7"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>_unitsInRange <span class="op">=</span> _cellsInRange<span class="op">.</span><span class="fu">SelectMany</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">).</span><span class="fu">ToList</span><span class="op">();</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">MarkAsReachableEnemy</span><span class="op">(</span>_unitsInRange<span class="op">);</span></span></code></pre></div>
      <h5 id="executing-the-ability">Executing the ability</h5>
      <p>When the player clicks on a highlighted cell, the
      <code>OnCellClicked</code> method executes. This method selects
      all units in the targeted area and executes the ability by
      invoking the <code>HumanExecuteAbility</code> method. This method
      uses the <code>MultipleTargetAttackCommand</code> to apply damage
      to all affected units:</p>
      <div class="sourceCode" id="cb8"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>UnitReference<span class="op">.</span><span class="fu">HumanExecuteAbility</span><span class="op">(</span><span class="kw">new</span> <span class="fu">MultipleTargetAttackCommand</span><span class="op">(</span>unitsInRange<span class="op">,</span> _damage<span class="op">),</span> gridController<span class="op">);</span></span></code></pre></div>
      <p>The MultipleTargetAttackCommand iterates through the units in
      range, applying the specified amount of damage:</p>
      <div class="sourceCode" id="cb9"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> target <span class="kw">in</span> _targets<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    target<span class="op">.</span><span class="fu">ModifyHealth</span><span class="op">(-</span>_damage<span class="op">,</span> unit<span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h5 id="canceling-the-ability">Canceling the Ability</h5>
      <p>Every ability needs to include a way to deselect it. Usually,
      this is done by setting a <code>GridStateAwaitInput</code> or
      <code>GridStateUnitSelected</code> object to the
      <code>GridController.GridState</code> field. In this case, when a
      friendly unit is clicked it is selected and therefore the
      FireballAbility is canceled:</p>
      <div class="sourceCode" id="cb10"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetFriendlyUnits</span><span class="op">(</span>unit<span class="op">.</span><span class="fu">PlayerNumber</span><span class="op">).</span><span class="fu">Contains</span><span class="op">(</span>unit<span class="op">))</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    gridController<span class="op">.</span><span class="fu">GridState</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridStateUnitSelected</span><span class="op">(</span>unit<span class="op">,</span> unit<span class="op">.</span><span class="fu">GetBaseAbilities</span><span class="op">());</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <p>Alternatively, a common way to cancel a special ability is to
      include a cancel button in your UI and assign
      <code>GridStateAwaitingInput</code> to the grid state.</p>
      <h5 id="cleaning-up-after-the-ability">Cleaning Up After the
      Ability</h5>
      <p>The OnCellDehighlighted and CleanUp methods ensure that once
      the ability is used or canceled, all highlighted cells and units
      return to their default states:</p>
      <div class="sourceCode" id="cb11"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_cellsInRange<span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_unitsInRange<span class="op">);</span></span></code></pre></div>
      <h5 id="full-code">Full code</h5>
      <div class="sourceCode" id="cb12"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> FireballAbility <span class="op">:</span> Ability</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> <span class="dt">int</span> _radius <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> <span class="dt">int</span> _damage <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> IEnumerable<span class="op">&lt;</span>ICell<span class="op">&gt;</span> _cellsInRange<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> IEnumerable<span class="op">&lt;</span>IUnit<span class="op">&gt;</span> _unitsInRange<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">OnCellHighlighted</span><span class="op">(</span>ICell cell<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        _cellsInRange <span class="op">=</span> gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">GetDistance</span><span class="op">(</span>cell<span class="op">)</span> <span class="op">&lt;=</span> _radius<span class="op">);</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">MarkAsReachable</span><span class="op">(</span>_cellsInRange<span class="op">);</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        _unitsInRange <span class="op">=</span> _cellsInRange<span class="op">.</span><span class="fu">SelectMany</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">).</span><span class="fu">ToList</span><span class="op">();</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">MarkAsReachableEnemy</span><span class="op">(</span>_unitsInRange<span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">OnCellClicked</span><span class="op">(</span>ICell cell<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> unitsInRange <span class="op">=</span> _cellsInRange<span class="op">.</span><span class="fu">SelectMany</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">).</span><span class="fu">ToList</span><span class="op">();</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        UnitReference<span class="op">.</span><span class="fu">HumanExecuteAbility</span><span class="op">(</span><span class="kw">new</span> <span class="fu">MultipleTargetAttackCommand</span><span class="op">(</span>unitsInRange<span class="op">,</span> _damage<span class="op">),</span> gridController<span class="op">);</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">OnUnitClicked</span><span class="op">(</span>IUnit unit<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetFriendlyUnits</span><span class="op">(</span>unit<span class="op">.</span><span class="fu">PlayerNumber</span><span class="op">).</span><span class="fu">Contains</span><span class="op">(</span>unit<span class="op">))</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>            gridController<span class="op">.</span><span class="fu">GridState</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridStateUnitSelected</span><span class="op">(</span>unit<span class="op">,</span> unit<span class="op">.</span><span class="fu">GetBaseAbilities</span><span class="op">());</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">OnCellDehighlighted</span><span class="op">(</span>ICell cell<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_cellsInRange<span class="op">);</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_unitsInRange<span class="op">);</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">CleanUp</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_cellsInRange<span class="op">);</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_unitsInRange<span class="op">);</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> MultipleTargetAttackCommand <span class="op">:</span> ICommand</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="kw">readonly</span> IEnumerable<span class="op">&lt;</span>IUnit<span class="op">&gt;</span> _targets<span class="op">;</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="kw">readonly</span> <span class="dt">int</span> _damage<span class="op">;</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="fu">MultipleTargetAttackCommand</span><span class="op">(</span>IEnumerable<span class="op">&lt;</span>IUnit<span class="op">&gt;</span> targets<span class="op">,</span> <span class="dt">int</span> damage<span class="op">)</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>            _targets <span class="op">=</span> targets<span class="op">;</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>            _damage <span class="op">=</span> damage<span class="op">;</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> Task <span class="fu">Execute</span><span class="op">(</span>IUnit unit<span class="op">,</span> GridController controller<span class="op">)</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>            controller<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">MarkAsAttacking</span><span class="op">(</span>unit<span class="op">,</span> _targets<span class="op">.</span><span class="fu">First</span><span class="op">());</span></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>            <span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> target <span class="kw">in</span> _targets<span class="op">)</span></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>                target<span class="op">.</span><span class="fu">ModifyHealth</span><span class="op">(-</span>_damage<span class="op">,</span> unit<span class="op">);</span></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> Task<span class="op">.</span><span class="fu">CompletedTask</span><span class="op">;</span></span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> Task <span class="fu">Undo</span><span class="op">(</span>IUnit unit<span class="op">,</span> GridController controller<span class="op">)</span></span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Implementation skipped for brevity</span></span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> Task<span class="op">.</span><span class="fu">CompletedTask</span><span class="op">;</span></span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h4 id="the-compoundability">The CompoundAbility</h4>
      <p>The <code>CompoundAbility</code> allows for the creation of
      abilities that act as containers for multiple selectable
      abilities. This can be useful for scenarios like a spellbook or a
      menu of different attacks, where the player must choose between
      several abilities.</p>
      <p>Here’s a breakdown of how the <code>CompoundAbility</code>
      works:</p>
      <h5 id="initializing-abilities">Initializing Abilities</h5>
      <p>The <code>CompoundAbility</code> contains a list of selectable
      abilities, which are set up during initialization. Each ability is
      registered with the unit, allowing them to be used during
      gameplay. This is done by iterating over the
      <code>_selectableAbilities</code> array and calling
      <code>RegisterAbility</code> for each one.</p>
      <div class="sourceCode" id="cb13"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Initialize</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> ability <span class="kw">in</span> _selectableAbilities<span class="op">)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        UnitReference<span class="op">.</span><span class="fu">RegisterAbility</span><span class="op">(</span>ability<span class="op">,</span> gridController<span class="op">);</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h5 id="displaying-abilities">Displaying Abilities</h5>
      <p>When the <code>CompoundAbility</code> is selected, it generates
      a button for each of the selectable abilities. These buttons are
      added as children to a predefined UI element (e.g., a menu), and
      each button is linked to one of the abilities. When a button is
      pressed, the game switches to the selected ability by setting the
      <code>GridState</code> to <code>GridStateUnitSelected</code>,
      passing the corresponding ability.</p>
      <div class="sourceCode" id="cb14"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Display</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> ability <span class="kw">in</span> _selectableAbilities<span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> buttonInstance <span class="op">=</span> GameObject<span class="op">.</span><span class="fu">Instantiate</span><span class="op">(</span>_buttonTemplate<span class="op">.</span><span class="fu">gameObject</span><span class="op">,</span> _buttonParent<span class="op">).</span><span class="fu">GetComponent</span><span class="op">&lt;</span>Button<span class="op">&gt;();</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        _buttons<span class="op">.</span><span class="fu">Add</span><span class="op">(</span>buttonInstance<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        buttonInstance<span class="op">.</span><span class="fu">onClick</span><span class="op">.</span><span class="fu">AddListener</span><span class="op">(()</span> <span class="op">=&gt;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            gridController<span class="op">.</span><span class="fu">GridState</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridStateUnitSelected</span><span class="op">(</span>UnitReference<span class="op">,</span> ability<span class="op">);</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*...*/</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Assign a text or image representing the ability to the button</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*...*/</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>        buttonInstance<span class="op">.</span><span class="fu">gameObject</span><span class="op">.</span><span class="fu">SetActive</span><span class="op">(</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    _buttonParent<span class="op">.</span><span class="fu">gameObject</span><span class="op">.</span><span class="fu">SetActive</span><span class="op">(</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h5 id="cleaning-up">Cleaning Up</h5>
      <p>To clean up after the <code>CompoundAbility</code> is
      deselected or canceled, all generated buttons are removed from the
      UI element, and the parent is hidden to prevent it from remaining
      visible.</p>
      <div class="sourceCode" id="cb15"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">CleanUp</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> _buttons<span class="op">.</span><span class="fu">Count</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>            GameObject<span class="op">.</span><span class="fu">Destroy</span><span class="op">(</span>_buttons<span class="op">[</span>i<span class="op">].</span><span class="fu">gameObject</span><span class="op">);</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        _buttons<span class="op">.</span><span class="fu">Clear</span><span class="op">();</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        _buttonParent<span class="op">.</span><span class="fu">gameObject</span><span class="op">.</span><span class="fu">SetActive</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
      <h5 id="full-code-1">Full code</h5>
      <div class="sourceCode" id="cb16"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> System<span class="op">.</span><span class="fu">Collections</span><span class="op">.</span><span class="fu">Generic</span><span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> System<span class="op">.</span><span class="fu">Linq</span><span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> UnityEngine<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> UnityEngine<span class="op">.</span><span class="fu">UI</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> System<span class="op">.</span><span class="fu">Threading</span><span class="op">.</span><span class="fu">Tasks</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SpellBookAbility <span class="op">:</span> Ability</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> List<span class="op">&lt;</span>Ability<span class="op">&gt;</span> _selectableAbilities<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> GameObject _buttonParent<span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> Button _buttonTemplate<span class="op">;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> IList<span class="op">&lt;</span>Button<span class="op">&gt;</span> _buttons <span class="op">=</span> <span class="kw">new</span> List<span class="op">&lt;</span>Button<span class="op">&gt;();</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Initialize</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> ability <span class="kw">in</span> _selectableAbilities<span class="op">)</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>            UnitReference<span class="op">.</span><span class="fu">RegisterAbility</span><span class="op">(</span>ability<span class="op">,</span> gridController<span class="op">);</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Display</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">foreach</span> <span class="op">(</span><span class="dt">var</span> ability <span class="kw">in</span> _selectableAbilities<span class="op">)</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> buttonInstance <span class="op">=</span> GameObject<span class="op">.</span><span class="fu">Instantiate</span><span class="op">(</span>_buttonTemplate<span class="op">.</span><span class="fu">gameObject</span><span class="op">,</span> _buttonParent<span class="op">).</span><span class="fu">GetComponent</span><span class="op">&lt;</span>Button<span class="op">&gt;();</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>            _buttons<span class="op">.</span><span class="fu">Add</span><span class="op">(</span>buttonInstance<span class="op">);</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>            buttonInstance<span class="op">.</span><span class="fu">onClick</span><span class="op">.</span><span class="fu">AddListener</span><span class="op">(()</span> <span class="op">=&gt;</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>                gridController<span class="op">.</span><span class="fu">GridState</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridStateUnitSelected</span><span class="op">(</span>UnitReference<span class="op">,</span> ability<span class="op">);</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">});</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">/*...*/</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Assign a text or image representing the ability to the button</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>            <span class="co">/*...*/</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>            buttonInstance<span class="op">.</span><span class="fu">gameObject</span><span class="op">.</span><span class="fu">SetActive</span><span class="op">(</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>        _buttonParent<span class="op">.</span><span class="fu">gameObject</span><span class="op">.</span><span class="fu">SetActive</span><span class="op">(</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">CleanUp</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> _buttons<span class="op">.</span><span class="fu">Count</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>            GameObject<span class="op">.</span><span class="fu">Destroy</span><span class="op">(</span>_buttons<span class="op">[</span>i<span class="op">].</span><span class="fu">gameObject</span><span class="op">);</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>        _buttons<span class="op">.</span><span class="fu">Clear</span><span class="op">();</span></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>        _buttonParent<span class="op">.</span><span class="fu">gameObject</span><span class="op">.</span><span class="fu">SetActive</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h2 id="7-ai-system">7. AI System</h2>
      <p>The AI in the Turn-Based Strategy Framework is built on
      Behaviour Trees, a system that allows for modular, scalable
      decision-making. Behaviour trees make it easier to define AI
      behaviours by breaking down decisions into simple, reusable
      components called nodes. This allows for flexibility in AI logic
      and makes debugging and extending AI behaviours much simpler.</p>
      <p>At the core of the AI system is the AIPlayer class, which
      controls the units assigned to it during its turn. Each unit
      controlled by the AI follows a set of decisions defined by its own
      behaviour tree. By default, the Framework provides a
      <code>RegularBehaviourTreeResource</code>, a general-purpose
      behaviour tree that handles standard actions like moving and
      attacking. The AIPlayer handles selecting units, triggering their
      behaviour trees, and executing actions on the grid.</p>
      <h3 id="aiplayer-and-unit-selection">AIPlayer and Unit
      Selection</h3>
      <p>In the Turn-Based Strategy Framework, the
      <strong>AIPlayer</strong> class is responsible for controlling
      units during its turn. AI players are set up automatically by the
      Grid Helper, or they can be manually added by attaching an
      <strong>AIPlayer</strong> script to a GameObject under the
      <strong>PlayersManager</strong> in the scene. During its turn, the
      AIPlayer selects units, commands them using their behaviour trees,
      and continues this process until all units have acted.</p>
      <p>The order in which the AI controls its units is determined by
      the <strong>IUnitSelector</strong> interface. The default
      implementation, <strong>RegularUnitSelector</strong>, selects
      units in the order provided by the <strong>UnitManager</strong>.
      In Unity, the <strong>IUnitSelector</strong> is implemented by
      <strong>UnityUnitSelector</strong>, which can be extended to
      implement custom selection strategies. For example, units could be
      prioritized based on health, proximity to enemies, or remaining
      action points. The unit selector is typically added as a child of
      the AIPlayer in the scene and assigned to its
      <code>_unitSelector</code> field.</p>
      <p>This approach allows flexibility in how the AIPlayer processes
      its units, enabling developers to create custom behaviors that fit
      specific game requirements.</p>
      <h3 id="behaviour-trees-and-nodes">Behaviour Trees and Nodes</h3>
      <p>In the Turn-Based Strategy Framework, AI actions are driven by
      <strong>behaviour trees</strong>. A behaviour tree is a modular
      system that breaks down AI decision-making into smaller,
      manageable components called <strong>nodes</strong>. Each node
      represents an action or decision and returns either
      <strong>true</strong> (success) or <strong>false</strong>
      (failure), which determines the flow of execution within the
      tree.</p>
      <p>At its core, the behaviour tree relies on the outcome of each
      node to control how the AI proceeds. If a node succeeds, the AI
      can move on to the next action or decision. If a node fails, the
      tree might choose a different path or retry an action. This
      flexibility allows behaviour trees to handle complex
      decision-making with relative ease. Nodes are structured
      hierarchically, meaning higher-level nodes determine which actions
      to take based on the success or failure of their child nodes.</p>
      <p>For example:</p>
      <ul>
      <li>A <strong>SequenceNode</strong> will execute its child nodes
      in order. If all child nodes succeed, the sequence is considered
      successful. However, if any child node fails, the sequence stops
      and returns failure.</li>
      <li>A <strong>SelectorNode</strong> works like an "if-else"
      statement. It checks its child nodes one by one, returning success
      as soon as one succeeds. If all child nodes fail, the selector
      returns failure.</li>
      </ul>
      <p>These nodes form the foundation of AI behaviour:</p>
      <ul>
      <li><strong>SuccederNode</strong>: Forces its child node to return
      success, even if it would normally fail.</li>
      <li><strong>InverterNode</strong>: Reverses the result of its
      child node (turning success into failure and vice versa).</li>
      <li><strong>DelayNode</strong>: Adds a time delay before the next
      node is executed, simulating a pause or deliberation in
      decision-making.</li>
      <li><strong>RandomNode</strong>: Introduces probabilistic
      behaviour by returning success or failure based on a specified
      probability. This node is useful for adding randomness to AI
      decisions, making AI behaviour less predictable.</li>
      <li><strong>DebugNode</strong>: Executes a custom action for
      debugging, such as printing a message or pausing AI for user
      input.</li>
      <li><strong>FuncNode</strong>: Executes an arbitrary function,
      allowing custom logic without needing a dedicated node class.
      Useful for rapid prototyping.</li>
      </ul>
      <p>In addition to these basic nodes, the framework provides
      <strong>custom nodes</strong> specifically designed for turn-based
      games:</p>
      <ul>
      <li><strong>HealthThresholdNode</strong>: Determines whether a
      unit’s health is above or below a certain threshold, guiding
      decisions like retreating or attacking.</li>
      <li><strong>EnemiesInRangeNode</strong>: Checks if there are enemy
      units within the unit’s attack range, allowing the AI to decide
      whether to engage or reposition.</li>
      <li><strong>CellTakenNode</strong>: Determines if a particular
      cell on the grid is occupied.</li>
      </ul>
      <h4 id="action-nodes-and-evaluators">Action Nodes and
      Evaluators</h4>
      <p>In behaviour trees, <strong>action nodes</strong>—also known as
      <strong>leaf nodes</strong>—are the final nodes that actually
      perform the actions decided by the tree. They are called leaf
      nodes because they do not have any child nodes and represent the
      "end" of a decision-making path. Once the behaviour tree has
      processed all its decisions through higher-level nodes (such as
      sequences or selectors), a leaf node executes the action. For
      executing custom abilities, a dedicated action node should be
      implemented.</p>
      <p>The framework includes built-in action nodes such as:</p>
      <ul>
      <li><strong>MoveActionNode</strong>: Directs the AI unit to move
      to a specific cell.</li>
      <li><strong>AttackActionNode</strong>: Commands the AI unit to
      perform an attack on an enemy unit.</li>
      </ul>
      <p>These action nodes are powered by <strong>evaluators</strong>
      that help the AI make decisions based on a variety of factors.
      Evaluators are used to assess potential positions (in the case of
      movement) or targets (in the case of attacks), assigning a score
      to each option. These scores help the AI choose the most strategic
      move or target.</p>
      <p>The <strong>IPositionEvaluator</strong> interface is used for
      evaluating positions on the grid, while the
      <strong>ITargetEvaluator</strong> interface is used for evaluating
      units as potential targets. Each evaluator calculates a score
      based on specific conditions, such as the distance to the target
      or the damage that could be inflicted.</p>
      <p>For example:</p>
      <ul>
      <li><strong>DamageDealtPositionEvaluator</strong>: Scores a
      position based on the amount of damage that can be dealt to enemy
      units from that position.</li>
      <li><strong>DamageReceivedPositionEvaluator</strong>: Scores a
      position based on how much damage the AI unit would receive from
      enemy units if it moved to that cell.</li>
      <li><strong>DistancePositionEvaluator</strong>: Scores positions
      based on their distance from the AI unit’s current location.</li>
      <li><strong>HealthTargetEvaluator</strong>: Scores targets based
      on their current health, prioritizing weaker enemies.</li>
      </ul>
      <p>Evaluators can be combined and weighted to adjust the AI’s
      behaviour. For instance, a <strong>MoveActionNode</strong> might
      use a combination of evaluators, giving higher weight to the
      <strong>DamageDealtPositionEvaluator</strong> to prioritize
      offensive positioning, while also considering
      <strong>DamageReceivedPositionEvaluator</strong> to avoid
      unnecessary risk. Parameters like the weight of each evaluator or
      thresholds can be fine-tuned to adjust the AI’s aggressiveness,
      cautiousness, or overall playstyle.</p>
      <h3 id="sample-behaviour-tree">Sample Behaviour Tree</h3>
      <p>In this section, we will walk through the process of creating a
      custom behaviour tree node to execute the FireballAbility, and
      then integrate this node into a simple behaviour tree for an AI
      unit. This demonstrates how you can extend the AI system to use
      custom abilities in strategic decision-making.</p>
      <h4 id="creating-a-castfireball-node">Creating a
      <code>CastFireball</code> node</h4>
      <p>First, we need to implement a custom behaviour tree node that
      will allow the AI to use the FireballAbility. This node will find
      the best target and execute the ability.</p>
      <h5 id="finding-the-target">Finding the target</h5>
      <p>The node searches for the optimal target by identifying the
      area where the most enemy units are concentrated. For simplicity,
      this example uses a basic method for selecting the target, but in
      a real scenario, a set of evaluators could be used to make a more
      informed decision.</p>
      <div class="sourceCode" id="cb17"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> targetCell <span class="op">=</span> _gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">()</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">OrderByDescending</span><span class="op">(</span>cell <span class="op">=&gt;</span> _gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">()</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">Where</span><span class="op">(</span>n <span class="op">=&gt;</span> n<span class="op">.</span><span class="fu">GetDistance</span><span class="op">(</span>cell<span class="op">)</span> <span class="op">&lt;=</span> _radius<span class="op">)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">Sum</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">.</span><span class="fu">Count</span> <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">?</span> <span class="op">(</span>c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">PlayerNumber</span> <span class="op">==</span> _unitReference<span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="dv">0</span><span class="op">))</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">FirstOrDefault</span><span class="op">();</span></span></code></pre></div>
      <h5 id="handling-failure">Handling failure</h5>
      <p>If no such cell is found, the node returns <code>false</code>
      to indicate that the execution failed.</p>
      <div class="sourceCode" id="cb18"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>targetCell <span class="op">==</span> <span class="kw">null</span><span class="op">)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> Task<span class="op">.</span><span class="fu">FromResult</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h5 id="executing-the-ability-1">Executing the ability</h5>
      <p>Once the best target is selected, the affected units are
      identified, and the command is executed using
      <code>Unit.AIExecuteAbility</code>. A
      <code>TaskCompletionSource</code> is used to delay the completion
      of the node until the command has finished executing.</p>
      <div class="sourceCode" id="cb19"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> targetUnits <span class="op">=</span> _gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">GetDistance</span><span class="op">(</span>targetCell<span class="op">)</span> <span class="op">&lt;=</span> _radius<span class="op">).</span><span class="fu">SelectMany</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="dt">var</span> tcs <span class="op">=</span> <span class="kw">new</span> TaskCompletionSource<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;();</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>_unitReference<span class="op">.</span><span class="fu">AIExecuteAbility</span><span class="op">(</span><span class="kw">new</span> FireballAbility<span class="op">.</span><span class="fu">MultipleTargetAttackCommand</span><span class="op">(</span>targetUnits<span class="op">,</span> _damage<span class="op">),</span> _gridController<span class="op">,</span> tcs<span class="op">);</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">return</span> tcs<span class="op">.</span><span class="fu">Task</span><span class="op">;</span></span></code></pre></div>
      <h5 id="full-code-2">Full code</h5>
      <div class="sourceCode" id="cb20"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CastFireballNode <span class="op">:</span> ITreeNode</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> IUnit _unitReference<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> IGridController _gridController<span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> _radius<span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> _damage<span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">CastFireballNode</span><span class="op">(</span>IUnit unitReference<span class="op">,</span> IGridController gridController<span class="op">,</span> <span class="dt">int</span> radius<span class="op">,</span> <span class="dt">int</span> damage<span class="op">)</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        _unitReference <span class="op">=</span> unitReference<span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        _gridController <span class="op">=</span> gridController<span class="op">;</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        _radius <span class="op">=</span> radius<span class="op">;</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        _damage <span class="op">=</span> damage<span class="op">;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> Task<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> <span class="fu">Execute</span><span class="op">()</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> targetCell <span class="op">=</span> _gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">()</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">OrderByDescending</span><span class="op">(</span>cell <span class="op">=&gt;</span> _gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">()</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span><span class="fu">Where</span><span class="op">(</span>n <span class="op">=&gt;</span> n<span class="op">.</span><span class="fu">GetDistance</span><span class="op">(</span>cell<span class="op">)</span> <span class="op">&lt;=</span> _radius<span class="op">)</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span><span class="fu">Sum</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">.</span><span class="fu">Count</span> <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>                    <span class="op">?</span> <span class="op">(</span>c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">PlayerNumber</span> <span class="op">==</span> _unitReference<span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>                    <span class="op">:</span> <span class="dv">0</span><span class="op">))</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">FirstOrDefault</span><span class="op">();</span> <span class="co">// Select the area where most enemies are concentrated</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>targetCell <span class="op">==</span> <span class="kw">null</span><span class="op">)</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> Task<span class="op">.</span><span class="fu">FromResult</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span> <span class="co">// Return false to indicate that the node failed to execute.</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> targetUnits <span class="op">=</span> _gridController<span class="op">.</span><span class="fu">CellManager</span><span class="op">.</span><span class="fu">GetCells</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">GetDistance</span><span class="op">(</span>targetCell<span class="op">)</span> <span class="op">&lt;=</span> _radius<span class="op">).</span><span class="fu">SelectMany</span><span class="op">(</span>c <span class="op">=&gt;</span> c<span class="op">.</span><span class="fu">CurrentUnits</span><span class="op">);</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> tcs <span class="op">=</span> <span class="kw">new</span> TaskCompletionSource<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;();</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>        _unitReference<span class="op">.</span><span class="fu">AIExecuteAbility</span><span class="op">(</span><span class="kw">new</span> FireballAbility<span class="op">.</span><span class="fu">MultipleTargetAttackCommand</span><span class="op">(</span>targetUnits<span class="op">,</span> _damage<span class="op">),</span> _gridController<span class="op">,</span> tcs<span class="op">);</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> tcs<span class="op">.</span><span class="fu">Task</span><span class="op">;</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h4 id="creating-custom-behaviour-tree">Creating custom Behaviour
      Tree</h4>
      <p>Creating custom behaviour trees involves extending the
      <code>BehaviourTreeResource</code> class and overriding its
      <code>Initialize</code> method. The implementation should assign
      the behaviour tree to the <code>BehaviourTree</code> property,
      which is accessed and executed by the AIPlayer during its turn.
      Let’s break down the implementation of a simple behaviour tree
      that uses the FireballAbility, moves to a better position, and
      attacks an enemy if one is within range.</p>
      <h5 id="the-tree-root">The tree root</h5>
      <p>The <code>SequenceNode</code> is used as the root of the tree.
      The node executes it's child nodes in sequence until one of them
      fails. In this case, we want the node to execute all it's child
      nodes.</p>
      <div class="sourceCode" id="cb21"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Initialize</span><span class="op">(</span>IUnit unit<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    BehaviourTree <span class="op">=</span> <span class="kw">new</span> <span class="fu">SequenceNode</span><span class="op">(</span><span class="kw">new</span> List<span class="op">&lt;</span>ITreeNode<span class="op">&gt;()</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>       <span class="co">/*...*/</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h5 id="casting-the-fireball">Casting the Fireball</h5>
      <p>To cast the Fireball, we use the previously introduced
      <code>CastFireballNode</code>. It is wrapped in a
      <code>SuccederNode</code>, ensuring that the sequence continues
      even if casting the Fireball fails for some reason (e.g., no valid
      target).</p>
      <div class="sourceCode" id="cb22"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="fu">SuccederNode</span><span class="op">(</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">new</span> <span class="fu">CastFireballNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">,</span> radius<span class="op">:</span> <span class="dv">2</span><span class="op">,</span> damage<span class="op">:</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">),</span></span></code></pre></div>
      <h5 id="moving-to-a-position">Moving to a position</h5>
      <p>The <code>MoveActionNode</code> is used to move the unit to a
      more advantageous position. It evaluates potential positions using
      a set of evaluators to determine the best option. Like the
      Fireball node, it is wrapped in a <code>SuccederNode</code> to
      ensure the sequence continues regardless of the result.</p>
      <div class="sourceCode" id="cb23"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="fu">SuccederNode</span><span class="op">(</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">new</span> <span class="fu">MoveActionNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">,</span> <span class="kw">new</span> List<span class="op">&lt;</span>IPositionEvaluator<span class="op">&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="fu">DamageGivenPositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> threshold<span class="op">:</span> <span class="dv">20</span><span class="op">),</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="fu">DamageReceivedPositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="op">-</span><span class="fl">0.8f</span><span class="op">),</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="fu">DistancePositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="op">-</span><span class="fl">0.1f</span><span class="op">,</span> threshold<span class="op">:</span> <span class="dv">10</span><span class="op">),</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="fu">RandomPositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="fl">0.001f</span><span class="op">)</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="op">),</span></span></code></pre></div>
      <h5 id="attacking-enemies">Attacking enemies</h5>
      <p>The attack sequence consists of two nodes: first, the
      <code>EnemiesInRangeNode</code> checks whether there are any
      enemies within attack range. If it succeeds, the
      <code>AttackActionNode</code> is executed, using target evaluators
      to prioritize the best target. Since this is the final action in
      the sequence, there’s no need to wrap it in a
      <code>SuccederNode</code>.</p>
      <div class="sourceCode" id="cb24"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="fu">SequenceNode</span><span class="op">(</span><span class="kw">new</span> List<span class="op">&lt;</span>ITreeNode<span class="op">&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">new</span> <span class="fu">EnemiesInRangeNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">),</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">new</span> <span class="fu">AttackActionNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">,</span> <span class="kw">new</span> List<span class="op">&lt;</span>ITargetEvaluator<span class="op">&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="fu">HealthTargetEvaluator</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">new</span> <span class="fu">DamageGivenTargetEvaluator</span><span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
      <h5 id="full-code-3">Full code</h5>
      <div class="sourceCode" id="cb25"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SimpleBehaviourTreeResource <span class="op">:</span> BehaviourTreeResource</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Initialize</span><span class="op">(</span>IUnit unit<span class="op">,</span> GridController gridController<span class="op">)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        BehaviourTree <span class="op">=</span> <span class="kw">new</span> <span class="fu">SequenceNode</span><span class="op">(</span><span class="kw">new</span> List<span class="op">&lt;</span>ITreeNode<span class="op">&gt;()</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">SuccederNode</span><span class="op">(</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="fu">CastFireballNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">,</span> radius<span class="op">:</span> <span class="dv">2</span><span class="op">,</span> damage<span class="op">:</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">),</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">SuccederNode</span><span class="op">(</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="fu">MoveActionNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">,</span> <span class="kw">new</span> List<span class="op">&lt;</span>IPositionEvaluator<span class="op">&gt;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">DamageGivenPositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> threshold<span class="op">:</span> <span class="dv">20</span><span class="op">),</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">DamageReceivedPositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="op">-</span><span class="fl">0.8f</span><span class="op">),</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">DistancePositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="op">-</span><span class="fl">0.1f</span><span class="op">,</span> threshold<span class="op">:</span> <span class="dv">10</span><span class="op">),</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">RandomPositionEvaluator</span><span class="op">(</span>weight<span class="op">:</span> <span class="fl">0.001f</span><span class="op">)</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">})</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">),</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">SequenceNode</span><span class="op">(</span><span class="kw">new</span> List<span class="op">&lt;</span>ITreeNode<span class="op">&gt;</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="fu">EnemiesInRangeNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">),</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>                <span class="kw">new</span> <span class="fu">AttackActionNode</span><span class="op">(</span>unit<span class="op">,</span> gridController<span class="op">,</span> <span class="kw">new</span> List<span class="op">&lt;</span>ITargetEvaluator<span class="op">&gt;</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">HealthTargetEvaluator</span><span class="op">(</span><span class="dv">1</span><span class="op">),</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">new</span> <span class="fu">DamageGivenTargetEvaluator</span><span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>                <span class="op">})</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">})</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h2 id="8-game-state-management">8. Game State Management</h2>
      <h3 id="user-interaction">User Interaction</h3>
      <p>User interaction with the game is managed by the
      <code>GridController</code> object. The
      <code>GridController</code> listens for various events, such as
      selecting a unit or cell, and delegates handling these events to a
      <code>GridState</code> object that is assigned to it. The project
      includes several <code>GridState</code> implementations, each
      designed for specific scenarios:</p>
      <ul>
      <li><strong><code>GridStateAwaitInput</code></strong> – The
      default state when the grid is waiting for player input,
      specifically for unit selection.</li>
      <li><strong><code>GridStateBlockInput</code></strong> – A state
      where all input is blocked, usually during the AI’s turn.</li>
      <li><strong><code>GridStateUnitSelected</code></strong> – The
      state when a unit is selected by the player, allowing interaction
      with that unit’s set of abilities.</li>
      <li><strong><code>GridStateGameEnded</code></strong> – A state
      that signals the end of the game, preventing any further
      interaction or state changes.</li>
      </ul>
      <p>To select a specific unit, you can change the grid state to
      <code>GridStateUnitSelected</code> like this:</p>
      <div class="sourceCode" id="cb26"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>gridController<span class="op">.</span><span class="fu">GridState</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridStateUnitSelected</span><span class="op">(</span>unit<span class="op">,</span> unit<span class="op">.</span><span class="fu">GetBaseAbilities</span><span class="op">());</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Selects the given unit along with its base abilities</span></span></code></pre></div>
      <p>To deselect the unit and return to the default input state:</p>
      <div class="sourceCode" id="cb27"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>gridController<span class="op">.</span><span class="fu">GridState</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridStateAwaitInput</span><span class="op">();</span></span></code></pre></div>
      <h3 id="turn-management">Turn Management</h3>
      <p>To properly end a player’s turn, use the
      <code>GridController.EndTurn()</code> method. In Unity, the
      <code>UnityGridController</code> wrapper class also provides this
      method, which delegates the call to the underlying
      <code>GridController</code>.</p>
      <p>The order in which players take turns is controlled by the
      <code>ITurnResolver</code> interface, which not only defines the
      turn order but also determines which units are allowed to act
      during each turn. The framework provides a default implementation,
      the <code>SubsequentTurnResolver</code>, which selects players
      sequentially, starting with the player who has the lowest player
      number and cycling through in order.</p>
      <p>This default behaviour is useful for many classic turn-based
      games, but if you need a more advanced system (such as speed-based
      turns or priority systems), you can create your own resolver by
      extending the <code>UnityTurnResolver</code>. You can easily swap
      out the resolver by assigning a new one to the
      <code>UnityGridController._turnResolver</code> field in the
      scene.</p>
      <p>Here’s the code for the default
      <code>SubsequentTurnResolver</code>, which is added to the scene
      by the GridHelper:</p>
      <div class="sourceCode" id="cb28"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> System<span class="op">.</span><span class="fu">Linq</span><span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> TurnBasedStrategyFramework<span class="op">.</span><span class="fu">Common</span><span class="op">.</span><span class="fu">Controllers</span><span class="op">.</span><span class="fu">TurnResolvers</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">readonly</span> <span class="kw">struct</span> SubsequentTurnResolverImpl <span class="op">:</span> ITurnResolver</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="kw">readonly</span> TurnContext <span class="fu">ResolveStart</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> nextPlayer <span class="op">=</span> gridController<span class="op">.</span><span class="fu">PlayerManager</span><span class="op">.</span><span class="fu">GetPlayers</span><span class="op">().</span><span class="fu">OrderBy</span><span class="op">(</span>p <span class="op">=&gt;</span> p<span class="op">.</span><span class="fu">PlayerNumber</span><span class="op">).</span><span class="fu">FirstOrDefault</span><span class="op">();</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> allowedUnits <span class="op">=</span> gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetUnits</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>u <span class="op">=&gt;</span> u<span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">==</span> nextPlayer<span class="op">.</span><span class="fu">PlayerNumber</span><span class="op">);</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">TurnContext</span><span class="op">(</span>nextPlayer<span class="op">,</span> allowedUnits<span class="op">);</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="kw">readonly</span> TurnContext <span class="fu">ResolveTurn</span><span class="op">(</span>GridController gridController<span class="op">)</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> numberOfPlayers <span class="op">=</span> gridController<span class="op">.</span><span class="fu">PlayerManager</span><span class="op">.</span><span class="fu">GetPlayers</span><span class="op">().</span><span class="fu">Count</span><span class="op">();</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> nextPlayerNumber <span class="op">=</span> <span class="op">(</span>gridController<span class="op">.</span><span class="fu">TurnContext</span><span class="op">.</span><span class="fu">CurrentPlayer</span><span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> numberOfPlayers<span class="op">;</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">while</span> <span class="op">(!</span>gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetUnits</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>u <span class="op">=&gt;</span> u<span class="op">.</span><span class="fu">PlayerNumber</span><span class="op">.</span><span class="fu">Equals</span><span class="op">(</span>nextPlayerNumber<span class="op">)).</span><span class="fu">Any</span><span class="op">())</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>                nextPlayerNumber <span class="op">=</span> <span class="op">(</span>nextPlayerNumber <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> numberOfPlayers<span class="op">;</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> nextPlayer <span class="op">=</span> gridController<span class="op">.</span><span class="fu">PlayerManager</span><span class="op">.</span><span class="fu">GetPlayers</span><span class="op">().</span><span class="fu">FirstOrDefault</span><span class="op">(</span>p <span class="op">=&gt;</span> p<span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">==</span> nextPlayerNumber<span class="op">);</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> allowedUnits <span class="op">=</span> gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetUnits</span><span class="op">().</span><span class="fu">Where</span><span class="op">(</span>u <span class="op">=&gt;</span> u<span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">==</span> nextPlayerNumber<span class="op">);</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> <span class="kw">new</span> <span class="fu">TurnContext</span><span class="op">(</span>nextPlayer<span class="op">,</span> allowedUnits<span class="op">);</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h3 id="ending-the-game">Ending the Game</h3>
      <p>The system for ending the game in the Turn-Based Strategy
      Framework is open-ended, meaning there is no built-in mechanism
      that constantly checks for game-ending conditions. Instead, it's
      based on a "tell, don't ask" approach, where the game doesn’t
      automatically monitor for an end condition. In other words,
      instead of the framework constantly checking game end conditions,
      you manually inform it when the game ends based on events you
      subscribe to. It’s up to you to track game progress and manually
      trigger the end by calling the
      <code>GridController.InvokeGameEnded(GameResult gameResult)</code>
      method when the conditions are met. There is no specific interface
      or rule for handling game-ending logic, giving you complete
      flexibility to implement custom scenarios.</p>
      <p>To handle this, you typically follow relevant events in the
      game (such as unit destruction or objective capture) and subscribe
      to those events. When a specific condition is met, you invoke the
      <code>InvokeGameEnded</code> method with the appropriate
      <code>GameResult</code>, like declaring a player as the winner.
      For example, the default implementation added by the GridHelper
      subscribes to the <code>unitDestroyed</code> event for every unit
      on the grid. It monitors the state of the game and checks if only
      one player has units remaining. If that’s the case, it calls
      <code>InvokeGameEnded</code>, declaring the last player standing
      as the winner. Here's the full code for this condition:</p>
      <div class="sourceCode" id="cb29"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DominationCondition <span class="op">:</span> MonoBehaviour</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> UnityUnitManager _unitManager<span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> UnityPlayerManager _playerManager<span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>SerializeField<span class="op">]</span> <span class="kw">private</span> UnityGridController _controller<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Awake</span><span class="op">()</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        _unitManager<span class="op">.</span><span class="fu">UnitRemoved</span> <span class="op">+=</span> OnUnitRemoved<span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">OnUnitRemoved</span><span class="op">(</span>IUnit unit<span class="op">)</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> playersWithUnitsAlive <span class="op">=</span> _unitManager<span class="op">.</span><span class="fu">GetUnits</span><span class="op">()</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>                                                <span class="op">.</span><span class="fu">Select</span><span class="op">(</span>u <span class="op">=&gt;</span> u<span class="op">.</span><span class="fu">PlayerNumber</span><span class="op">)</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>                                                <span class="op">.</span><span class="fu">Distinct</span><span class="op">();</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>playersWithUnitsAlive<span class="op">.</span><span class="fu">Count</span><span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> winner <span class="op">=</span> _playerManager<span class="op">.</span><span class="fu">GetPlayers</span><span class="op">()</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>                                       <span class="op">.</span><span class="fu">First</span><span class="op">(</span>p <span class="op">=&gt;</span> p<span class="op">.</span><span class="fu">PlayerNumber</span> <span class="op">==</span> playersWithUnitsAlive<span class="op">.</span><span class="fu">First</span><span class="op">());</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> losers <span class="op">=</span> _playerManager<span class="op">.</span><span class="fu">GetPlayers</span><span class="op">()</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>                                       <span class="op">.</span><span class="fu">Where</span><span class="op">(</span>p <span class="op">=&gt;</span> p <span class="op">!=</span> winner<span class="op">);</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>            _controller<span class="op">.</span><span class="fu">InvokeGameEnded</span><span class="op">(</span><span class="kw">new</span> <span class="fu">GameResult</span><span class="op">(</span>winner<span class="op">,</span> losers<span class="op">));</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <p>For organizational purposes, the default script is placed under
      a dedicated empty node called <code>GameEndConditions</code>, with
      the script as its child. However, this is not required. You can
      place the game-ending script anywhere in the scene as long as it
      can access the necessary events and call the
      <code>InvokeGameEnded</code> method at the right time.</p>
      <p>This flexible system allows for a wide variety of game-ending
      conditions. For example, you could implement a timed match where
      the game ends after a set number of turns by subscribing to the
      <code>UnityGridController.TurnEnded</code> to count turns.
      Alternatively, you could create objective-based victory conditions
      by tracking whether specific position is captured, using the
      <code>Unit.UnitEnteredCell</code> event. For score-based games,
      you might follow your custom score-counting system and call
      <code>InvokeGameEnded</code> when a player reaches a certain score
      threshold. This open-ended event-driven approach makes it easy to
      customize the conditions that end your game.</p>
      <h2 id="9-online-multiplayer">9. Online Multiplayer</h2>
      <p>The Framework includes online play capabilities, allowing for
      the integration of multiplayer features into your games. This
      chapter provides a quickstart guide, outlining the essential steps
      for incorporating online play. Key aspects include setting up a
      NetworkConnection, managing server connections, and ensuring
      consistent game state across all client instances.</p>
      <h3 id="architecture">Architecture</h3>
      <p>The core of online play is the abstract
      <code>NetworkConnection</code> class. It intercepts all
      game‑critical actions (e.g. activating an ability, ending a turn),
      serializes them, broadcasts to other clients, then deserializes
      and applies them—guaranteeing a consistent game state everywhere.
      The architecture is peer-to-peer: each client is responsible for
      broadcasting its own actions and interpreting incoming ones. A
      central server is still used for user authentication, room
      discovery, and message relay, but no gameplay logic needs to run
      on the server. This simplifies hosting, reduces backend
      complexity, and allows developers to build fully playable online
      matches without writing authoritative server code. The tradeoff is
      reduced cheat resistance and less control over enforcement.</p>
      <p>Any online play service provider can be used, as long as a
      custom <code>NetworkConnection</code> implementation is provided
      that integrates with that provider's API.</p>
      <p>Key responsibilities of your <code>NetworkConnection</code>
      implementation:</p>
      <ul>
      <li><strong>Server Connection</strong>: Establish and manage the
      socket/session to your game server.</li>
      <li><strong>Room Management</strong>: Create, list and join public
      or private match rooms.</li>
      <li><strong>Player Management</strong>: Track players
      entering/leaving rooms and maintain their metadata.</li>
      <li><strong>Match State Communication</strong>: Send/receive all
      in‑game actions and state changes.</li>
      <li><strong>RNG Initialization</strong>: Seed
      <code>UnityEngine.Random</code> the same on all clients for
      reproducible randomness.</li>
      </ul>
      <p>A complete Nakama‑based example implementation is available on
      GitHub: <a
      href="https://github.com/mzetkowski/tbsf-nakama-client">nakama-client</a></p>
      <h3 id="scene-setup">Scene Setup</h3>
      <p>Follow these steps to set up the scene for online play:</p>
      <ol type="1">
      <li><strong>Disable immediate start</strong>
      <ul>
      <li>Open your main scene, select the <code>CellGrid</code>
      component and uncheck
      <strong>ShouldStartGameImmediately</strong>.</li>
      </ul></li>
      <li><strong>Add the Network GUI</strong>
      <ul>
      <li>Drag <strong>Prefabs/NetworkGUI</strong> into your
      hierarchy.</li>
      </ul></li>
      <li><strong>Attach your NetworkConnection</strong>
      <ul>
      <li>Create an empty GameObject, attach your
      <code>NetworkConnection</code> subclass (eg,
      <code>NakamaConnection</code> from the client package).</li>
      </ul></li>
      <li><strong>Wire up references</strong>
      <ul>
      <li>In the <code>NetworkGUI</code> inspector, assign the
      <strong>GridController</strong>,
      <strong>NetworkConnection</strong>, and
      <strong>PlayersParent</strong> fields.</li>
      </ul></li>
      </ol>
      <h3 id="network-gui">Network GUI</h3>
      <p>The provided <code>NetworkGUI</code> prefab handles:</p>
      <ul>
      <li><strong>Server Login</strong>: Enter a username and
      connect.</li>
      <li><strong>Room Creation</strong>: Create a new public or private
      room.</li>
      <li><strong>Room Listing</strong>: Browse and refresh public
      matches.</li>
      <li><strong>Room Joining</strong>: Join an existing match.</li>
      <li><strong>Player Readiness</strong>: Select player number and
      toggle “Ready” state.</li>
      </ul>
      <h3 id="game-state-synchronization">Game State
      Synchronization</h3>
      <p>To keep the game state consistent between clients, all
      actions—such as movement, attacks, other abilities and ending a
      turn—are serialized, transmitted, deserialized, and then executed.
      Every <code>Command</code> implementing <code>ICommand</code>
      should provide <code>Serialize</code> and <code>Deserialize</code>
      methods. Basic commands in the Framework, like
      <code>AttackCommand</code>, already implement these methods. Here
      is an example:</p>
      <div class="sourceCode" id="cb30"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> Dictionary<span class="op">&lt;</span><span class="dt">string</span><span class="op">,</span> <span class="dt">object</span><span class="op">&gt;</span> <span class="fu">Serialize</span><span class="op">()</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">new</span> Dictionary<span class="op">&lt;</span><span class="dt">string</span><span class="op">,</span> <span class="dt">object</span><span class="op">&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> SerializationKeys<span class="op">.</span><span class="fu">TargetID</span><span class="op">,</span> _target<span class="op">.</span><span class="fu">UnitID</span> <span class="op">},</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> SerializationKeys<span class="op">.</span><span class="fu">Damage</span><span class="op">,</span> _damage <span class="op">},</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> SerializationKeys<span class="op">.</span><span class="fu">ActionCost</span><span class="op">,</span> _actionCost <span class="op">}</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> ICommand <span class="fu">Deserialize</span><span class="op">(</span>Dictionary<span class="op">&lt;</span><span class="dt">string</span><span class="op">,</span> <span class="dt">object</span><span class="op">&gt;</span> actionParams<span class="op">,</span> IGridController gridController<span class="op">)</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">var</span> target <span class="op">=</span> gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetUnits</span><span class="op">().</span><span class="fu">First</span><span class="op">(</span>u <span class="op">=&gt;</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        u<span class="op">.</span><span class="fu">UnitID</span> <span class="op">==</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>actionParams<span class="op">[</span>SerializationKeys<span class="op">.</span><span class="fu">TargetID</span><span class="op">]);</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">var</span> damage <span class="op">=</span> <span class="op">(</span><span class="dt">float</span><span class="op">)</span>actionParams<span class="op">[</span>SerializationKeys<span class="op">.</span><span class="fu">Damage</span><span class="op">];</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">var</span> actionCost <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>actionParams<span class="op">[</span>SerializationKeys<span class="op">.</span><span class="fu">ActionCost</span><span class="op">];</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">AttackCommand</span><span class="op">(</span>target<span class="op">,</span> damage<span class="op">,</span> actionCost<span class="op">);</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <p>Both command execution and turn-end synchronization are handled
      automatically by the <code>NetworkConnection</code> class, so you
      don’t need to manually send these events for standard
      gameplay.</p>
      <h3 id="additional-actions">Additional Actions</h3>
      <p>For custom events—like map selection, specific match
      parameters, player readiness, or choosing player numbers—you'll
      need to register handlers and send state updates manually. A
      handler is simply a function that runs when a message with a
      specific opcode is received by the client. You register it using
      <code>AddHandler</code>, passing the action and the opcode. When
      that message is received, the corresponding handler will be
      invoked with the provided parameters. Opcodes are integer
      constants that uniquely identify message types in your game
      protocol. Values 0–3 are reserved by the Framework for core game
      actions. When defining your own opcodes for custom events, start
      from 4 or higher to avoid collisions with the built-in message
      types. To broadcast a custom event to other instances, use the
      <code>SendMatchState</code> method with specific OpCode and a
      dictionary containing event parameters.</p>
      <p>Here's how player readiness and selecting a player number are
      handled in the <code>NetworkGUI</code> class:</p>
      <div class="sourceCode" id="cb31"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="dt">void</span> <span class="fu">Start</span><span class="op">()</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    _networkConnection<span class="op">.</span><span class="fu">AddHandler</span><span class="op">((</span>actionParams<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">OnPlayerNumberChanged</span><span class="op">(</span>actionParams<span class="op">),</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>OpCode<span class="op">.</span><span class="fu">PlayerNumberChanged</span><span class="op">);</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    _networkConnection<span class="op">.</span><span class="fu">AddHandler</span><span class="op">((</span>actionParams<span class="op">)</span> <span class="op">=&gt;</span> <span class="fu">OnPlayerReadyChanged</span><span class="op">(</span>actionParams<span class="op">),</span> <span class="op">(</span><span class="dt">long</span><span class="op">)</span>OpCode<span class="op">.</span><span class="fu">IsReadyChanged</span><span class="op">);</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> GameObject <span class="fu">CreatePlayerPanel</span><span class="op">(</span>NetworkUser user<span class="op">,</span> <span class="dt">int</span> userIndex<span class="op">,</span> <span class="dt">int</span> maxUserCount<span class="op">,</span> <span class="dt">string</span> playerNumber<span class="op">,</span> <span class="dt">bool</span> isReady<span class="op">)</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* ... UI setup code ... */</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>user<span class="op">.</span><span class="fu">UserID</span><span class="op">.</span><span class="fu">Equals</span><span class="op">(</span>_localUser<span class="op">.</span><span class="fu">UserID</span><span class="op">))</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*...*/</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        playerSelectionPanelInstance<span class="op">.</span><span class="fu">transform</span><span class="op">.</span><span class="fu">Find</span><span class="op">(</span><span class="st">&quot;PlayerNumber&quot;</span><span class="op">).</span><span class="fu">GetComponent</span><span class="op">&lt;</span>InputField<span class="op">&gt;().</span><span class="fu">onValueChanged</span><span class="op">.</span><span class="fu">AddListener</span><span class="op">((</span>value<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> actionParams <span class="op">=</span> <span class="kw">new</span> Dictionary<span class="op">&lt;</span><span class="dt">string</span><span class="op">,</span> <span class="dt">object</span><span class="op">&gt;</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span> <span class="st">&quot;user_id&quot;</span><span class="op">,</span> _localUser<span class="op">.</span><span class="fu">UserID</span> <span class="op">},</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span> <span class="st">&quot;player_number&quot;</span><span class="op">,</span> value<span class="op">.</span><span class="fu">ToString</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>            _networkConnection<span class="op">.</span><span class="fu">SendMatchState</span><span class="op">((</span><span class="dt">long</span><span class="op">)</span>OpCode<span class="op">.</span><span class="fu">PlayerNumberChanged</span><span class="op">,</span> actionParams<span class="op">);</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>user<span class="op">.</span><span class="fu">UserID</span><span class="op">.</span><span class="fu">Equals</span><span class="op">(</span>_localUser<span class="op">.</span><span class="fu">UserID</span><span class="op">))</span></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>        playerSelectionPanelInstance<span class="op">.</span><span class="fu">transform</span><span class="op">.</span><span class="fu">Find</span><span class="op">(</span><span class="st">&quot;IsReady&quot;</span><span class="op">).</span><span class="fu">GetComponent</span><span class="op">&lt;</span>Toggle<span class="op">&gt;().</span><span class="fu">onValueChanged</span><span class="op">.</span><span class="fu">AddListener</span><span class="op">((</span>value<span class="op">)</span> <span class="op">=&gt;</span></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>            <span class="dt">var</span> actionParams <span class="op">=</span> <span class="kw">new</span> Dictionary<span class="op">&lt;</span><span class="dt">string</span><span class="op">,</span> <span class="dt">object</span><span class="op">&gt;</span></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span> <span class="st">&quot;user_id&quot;</span><span class="op">,</span> _localUser<span class="op">.</span><span class="fu">UserID</span> <span class="op">},</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>                <span class="op">{</span> <span class="st">&quot;is_ready&quot;</span><span class="op">,</span> value<span class="op">.</span><span class="fu">ToString</span><span class="op">()</span> <span class="op">}</span></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>            _networkConnection<span class="op">.</span><span class="fu">SendMatchState</span><span class="op">((</span><span class="dt">long</span><span class="op">)</span>OpCode<span class="op">.</span><span class="fu">IsReadyChanged</span><span class="op">,</span> actionParams<span class="op">);</span></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*...*/</span></span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h3 id="nakama-integration">Nakama Integration</h3>
      <p>Nakama by Heroic Labs is an open-source server for realtime
      multiplayer games. A custom Nakama client and server is
      implemented for the Turn Based Strategy Framework. For legal
      reasons, these are not included with the project, but available on
      GitHub instead.</p>
      <ul>
      <li><strong>Server</strong>: Clone and run the custom Nakama
      server at
      <code>github.com/mzetkowski/tbsf-nakama-server</code>.</li>
      <li><strong>Client</strong>: Install the Unity package from
      <code>github.com/mzetkowski/tbsf-nakama-client</code>.</li>
      <li><strong>Disclaimer</strong>: This project is not endorsed by
      or affiliated with Heroic Labs. "Nakama" is a trademark of Heroic
      Labs and is used here for descriptive purposes only. This
      project's use of the "Nakama" name is not intended to imply any
      affiliation with or endorsement by Heroic Labs.</li>
      </ul>
      <h2 id="10-tutorial">10. Tutorial</h2>
      <p>This tutorial will guide you through creating a basic scene
      using the Turn-Based Strategy Framework, focusing on assembling
      the necessary components without writing any code. Using tools
      provided in the framework, such as the
      <strong>GridHelper</strong>, you will set up a square-based map,
      add obstacles, and place two human players, each controlling a few
      units. This hands-on approach is designed to give you practical
      experience with the framework’s features, allowing you to see the
      mechanics in action and understand how the various elements work
      together. By the end, you will have a fully playable scene. The
      completed tutorial can be found in the
      <code>Assets/Examples/tutorial</code> folder.</p>
      <h3 id="cell-template">Cell Template</h3>
      <p>Before generating our map, we need to create its fundamental
      building block: a single, reusable cell. This <strong>cell
      prefab</strong> will define the appearance and basic behaviour of
      every square on our grid. To create a basic square cell, follow
      the steps outlined below. This guide walks you through setting up
      the cell structure, adding visual components, and configuring
      interaction using the <code>Square.cs</code> script.</p>
      <h4 id="1-create-a-new-scene">1. Create a New Scene</h4>
      <ul>
      <li>In Unity Editor, create and open a new scene by clicking on
      <strong>File &gt; New Scene</strong>.</li>
      </ul>
      <h4 id="2-create-a-cube">2. Create a Cube</h4>
      <ul>
      <li>Select <strong>GameObject &gt; 3D &gt; Cube</strong> to create
      a new cube</li>
      <li>Take note that the created cube includes a collider, a mesh
      and a material</li>
      </ul>
      <h4 id="3-add-a-squarecs-script-to-the-cube">3. Add a Square.cs
      script to the cube</h4>
      <ul>
      <li>Attach the <code>Square.cs</code> to the cube. You can find it
      in <code>Assets/Scripts/cells/</code> folder</li>
      </ul>
      <h4 id="4-set-up-visual-highlighters">4. Set Up Visual
      Highlighters</h4>
      <p>To provide visual feedback (such as highlighting cells for
      selection), we will set up highlighters. These nodes modify the
      color of the cell in different game states (e.g., selected,
      reachable, or path).</p>
      <ul>
      <li><p>Add an empty child <strong>GameObject</strong> to the cube
      and name it <strong>Highlighters</strong>. This node will group
      the different highlight states.</p>
      <ul>
      <li>Right-click on the cube <strong>GameObject</strong> and select
      <strong>Create Empty</strong>, then rename the new object to
      <code>Highlighters</code>.</li>
      </ul></li>
      <li><p>For each state (<strong>UnMark</strong>,
      <strong>MarkAsHighlighted</strong>,
      <strong>MarkAsReachable</strong>, and
      <strong>MarkAsPath</strong>), add an empty
      <strong>GameObject</strong> as a child of
      <strong>Highlighters</strong>, attach the
      <code>RendererHighlighter.cs</code> script, and configure the
      color:</p></li>
      <li><p><strong>UnMark</strong>:</p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named "UnMark" as
      a child of <code>Highlighters</code>.</li>
      <li>Attach the <code>RendererHighlighter.cs</code> script to
      it.</li>
      <li>On the <code>RendererHighlighter</code> component, set
      <code>_color</code> to white.</li>
      <li>Drag the <code>Cube</code> GameObject into the
      <code>_renderer</code> field.</li>
      </ul></li>
      </ul>
      <blockquote>
      <p><strong>Tip:</strong> Copy the <strong>UnMark</strong>
      GameObject 3 times and adjust the parameters as below. This saves
      time and reduces repetitive setup by duplicating the GameObject
      with its attached script and assigned renderer.</p>
      </blockquote>
      <ul>
      <li><p><strong>MarkAsHighlighted</strong>:</p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsHighlighted" as a child of <code>Highlighters</code>.</li>
      <li>Attach the <code>RendererHighlighter.cs</code> script to
      it.</li>
      <li>On the <code>RendererHighlighter</code> component, set
      <code>_color</code> to blue.</li>
      <li>Drag the <code>Cube</code> GameObject into the
      <code>_renderer</code> field.</li>
      </ul></li>
      <li><p><strong>MarkAsReachable</strong>:</p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsReachable" as a child of <code>Highlighters</code>.</li>
      <li>Attach the <code>RendererHighlighter.cs</code> script to
      it.</li>
      <li>On the <code>RendererHighlighter</code> component, set
      <code>_color</code> to yellow.</li>
      <li>Drag the <code>Cube</code> GameObject into the
      <code>_renderer</code> field.</li>
      </ul></li>
      <li><p><strong>MarkAsPath</strong>:</p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named "MarkAsPath"
      as a child of <code>Highlighters</code>.</li>
      <li>Attach the <code>RendererHighlighter.cs</code> script to
      it.</li>
      <li>On the <code>RendererHighlighter</code> component, set
      <code>_color</code> to green.</li>
      <li>Drag the <code>Cube</code> GameObject into the
      <code>_renderer</code> field.</li>
      </ul></li>
      </ul>
      <h4 id="5-assign-highlighters-to-the-square-script">5. Assign
      Highlighters to the Square Script</h4>
      <p>Now that you have set up the highlighters, assign them to the
      corresponding fields in the <code>Square.cs</code> script to
      ensure that visual feedback works correctly during gameplay.</p>
      <ol type="1">
      <li>Select the cube GameObject.</li>
      <li>In the <strong>Inspector</strong>, locate the fields
      <code>_unMarkFn</code>, <code>_markAsHighlighted</code>,
      <code>_markAsReachableFn</code>, and <code>_markAsPathFn</code>
      from the attached <code>Square.cs</code> script.</li>
      <li>Assign the correct highlighter GameObjects to these fields:
      <ul>
      <li>Assign the <strong>UnMark</strong> GameObject to the
      <code>_unMarkFn</code> field.</li>
      <li>Assign the <strong>MarkAsHighlighted</strong> GameObject to
      the <code>_markAsHighlighted</code> field.</li>
      <li>Assign the <strong>MarkAsReachable</strong> GameObject to the
      <code>_markAsReachableFn</code> field.</li>
      <li>Assign the <strong>MarkAsPath</strong> GameObject to the
      <code>_markAsPathFn</code> field.</li>
      </ul></li>
      </ol>
      <p>After completing this step, your cell will be fully functional,
      providing visual feedback based on the player's interaction and
      responding to different game states.</p>
      <h4 id="6-save-the-cell-prefab">6. Save the cell prefab</h4>
      <ul>
      <li>Drag the cube from the Hierarchy panel into the Project panel
      to save it as a prefab.</li>
      </ul>
      <h3 id="generating-the-grid-using-the-grid-helper">Generating the
      Grid Using the Grid Helper</h3>
      <p>Now that the basic cell template is ready, it's time to
      generate the grid for your scene. The Turn-Based Strategy
      Framework includes a handy tool called <strong>GridHelper</strong>
      that automates grid creation, allowing you to quickly generate a
      grid using the cell template you just created.</p>
      <h4 id="7-access-the-grid-helper-panel">7. <strong>Access the Grid
      Helper panel</strong>:</h4>
      <ul>
      <li>Select <strong>Window &gt; Grid Helper</strong> to acess the
      Grid Helper panel.</li>
      </ul>
      <h4 id="8-configure-grid-parameters">8. <strong>Configure Grid
      Parameters</strong>:</h4>
      <ul>
      <li>In the <strong>GridHelper</strong> panel, configure the
      following settings to match the scene setup:
      <ul>
      <li><strong>Human Players No</strong>: Set this to <code>2</code>
      to include two human players.</li>
      <li><strong>AI Players No</strong>: Leave this at <code>0</code>
      since the tutorial focuses on human players only.</li>
      <li><strong>Is 2D Map</strong>: Leave this unchecked as the map is
      3D-based.</li>
      <li><strong>Cell Prefab</strong>: Drag and drop the cell prefab
      you created earlier into this field.</li>
      <li><strong>Map Width and Height</strong>: Set both the
      <strong>Map Width</strong> and <strong>Map Height</strong> to
      <code>10</code> to generate a 10x10 grid.</li>
      </ul></li>
      </ul>
      <h4 id="10-generate-the-grid">10. <strong>Generate the
      Grid</strong>:</h4>
      <ul>
      <li>Once all parameters are set, click the <strong>Generate
      Scene</strong> button. The GridHelper will automatically generate
      a 10x10 grid, with each cell based on the square cell template
      you've provided.</li>
      </ul>
      <p>By following these steps, you will have a functional,
      grid-based map with two human players, ready for gameplay
      interactions.</p>
      <h3 id="creating-an-obstacle-cell">Creating an Obstacle Cell</h3>
      <p>To add variety to the map and create impassable areas, we’ll
      create a modified version of the basic square cell with a "rock"
      on top, which will serve as an obstacle. This obstacle cell
      inherits from the previous square cell you created, maintaining
      the core grid functionality while adding an additional mesh to
      represent the rock.</p>
      <h4 id="10-create-a-prefab-variant">10. <strong>Create a prefab
      variant</strong>:</h4>
      <ul>
      <li>Navigate to the cell prefab created before, right-click on it
      and select <strong>Create &gt; Prefab Variant</strong>.</li>
      <li>Double-click the new prefab to open it for editing.</li>
      </ul>
      <h4 id="11-add-the-rock-mesh">11. <strong>Add the Rock
      Mesh</strong>:</h4>
      <ul>
      <li>Right-click on the root Game Object in the prefab and select
      <strong>Create &gt; 3D &gt; Cube</strong></li>
      <li>With the new <strong>Cube</strong> selected, go to the
      Inspector panel and:
      <ul>
      <li>Under <strong>Transform</strong>, adjust
      <strong>Scale</strong> to <code>(0.75, 0.75, 0.75)</code> and
      <strong>Translation</strong> to <code>(0, 0.75, 0)</code> to place
      it slightly raised above the cell.</li>
      <li>Right-click in the Project panel and select <strong>Create
      &gt; Material</strong> to create a new material. Assign the new
      material to the <code>Material</code> field on the Mesh Renderer
      component.</li>
      <li>Adjust the <strong>Albedo</strong> property of the new
      material to black to differentiate it visually as a rock.</li>
      </ul></li>
      </ul>
      <h4 id="12-mark-the-obstacle-cell-as-occupied">12. <strong>Mark
      the Obstacle Cell as Occupied</strong>:</h4>
      <ul>
      <li>Since this cell has a rock on it and should act as an
      obstacle, make sure to set the
      <strong><code>isTaken</code></strong> property in the
      <code>Square.cs</code> script to <code>true</code>.</li>
      </ul>
      <h4 id="13-save-the-obstacle-cell-prefab">13. <strong>Save the
      Obstacle Cell Prefab</strong>:</h4>
      <ul>
      <li>Save the prefab to keep the obstacle cell’s setup intact. The
      cell is now ready to act as an obstacle on your map.</li>
      </ul>
      <p>With this setup, the obstacle cell can now be used as a tile
      type in the map. Next, we’ll use the <strong>Tile Painter</strong>
      tool to place these obstacles on the map.</p>
      <h3 id="painting-obstacles-onto-the-grid">Painting Obstacles onto
      the Grid</h3>
      <h4 id="14-open-the-tile-painter">14. <strong>Open the Tile
      Painter</strong>:</h4>
      <ul>
      <li>With the generated grid scene open, go to the
      <strong>GridHelper</strong> panel.</li>
      <li>Find the <strong>Tile Painter</strong> section, where you’ll
      be able to select and apply different cell types to specific parts
      of the grid.</li>
      </ul>
      <h4 id="15-select-the-obstacle-cell">15. <strong>Select the
      Obstacle Cell</strong>:</h4>
      <ul>
      <li>In the <strong>Tile Painter</strong> options, set the
      <strong>Tile Prefab</strong> to the obstacle cell prefab you just
      created.</li>
      </ul>
      <h4 id="16-enter-tile-edit-mode">16. <strong>Enter Tile Edit
      Mode</strong>:</h4>
      <ul>
      <li>Click <strong>Enter Tile Edit Mode</strong> to enable painting
      on the grid. Now, any cell you click on will be replaced by the
      selected obstacle cell.</li>
      </ul>
      <h4 id="17-paint-the-obstacles">17. <strong>Paint the
      Obstacles</strong>:</h4>
      <ul>
      <li>Click on cells across the grid to replace them with the
      obstacle tile.</li>
      </ul>
      <h4 id="18-exit-tile-edit-mode">18. <strong>Exit Tile Edit
      Mode</strong>:</h4>
      <ul>
      <li>When you’re done, click <strong>Exit Tile Edit Mode</strong>
      to return to the standard scene editing view.</li>
      </ul>
      <p>By following these steps, you’ve added obstacles to your map,
      enhancing its strategic layout with simple, flexible tools.</p>
      <h3 id="creating-the-unit-template">Creating the Unit
      Template</h3>
      <p>To set up a unit template in Unity, we’ll create a new unit
      prefab with visual elements, collision detection, and interactive
      capabilities. This unit template will serve as the base for all
      player-controlled and AI units on the battlefield. Let’s walk
      through the steps to build this unit template from scratch.</p>
      <h4 id="19-create-an-empty-game-object">19. <strong>Create an
      Empty Game Object</strong>:</h4>
      <ul>
      <li>Start by creating an empty <strong>GameObject</strong>: click
      on <strong>GameObject &gt; Create Empty</strong>. Rename it
      <code>Unit</code>. This <code>Unit</code> GameObject will be the
      root of your unit prefab.</li>
      </ul>
      <h4 id="20-attach-the-unit-script">20. <strong>Attach the Unit
      Script</strong>:</h4>
      <ul>
      <li>With the <code>Unit</code> GameObject selected in the
      <strong>Hierarchy</strong>, click <strong>Add Component</strong>
      in the <strong>Inspector</strong>. Search for and select the
      <code>Unit.cs</code> script. You'll typically find it in
      <code>Assets/Scripts/units/</code>.</li>
      </ul>
      <h4 id="21-add-the-units-3d-model">21. <strong>Add the Unit’s 3D
      model</strong>:</h4>
      <ul>
      <li>To represent the unit visually, add a <strong>Cube</strong> as
      a child of the <code>Unit</code> GameObject.
      <ul>
      <li>Right-click on the <code>Unit</code> GameObject in the
      Hierarchy and select <strong>3D Object &gt; Cube</strong>. Rename
      this new Cube <code>UnitMesh</code>.</li>
      </ul></li>
      <li>Adjust the <strong>Transform</strong> properties of
      <code>UnitMesh</code> in the <strong>Inspector</strong>:
      <ul>
      <li>Set <strong>Scale</strong> to <code>(0.75, 0.75, 0.75)</code>
      to resize the cube.</li>
      <li>Set <strong>Position</strong> to <code>(0, 1.25, 0)</code> to
      place the cube slightly elevated from the ground.</li>
      </ul></li>
      </ul>
      <h4 id="22-add-an-additional-mesh-for-highlighting">22.
      <strong>Add an Additional Mesh for Highlighting</strong>:</h4>
      <ul>
      <li>Create a second <strong>Cube</strong> as a child of the root
      <code>Unit</code> GameObject. This mesh will provide a visual
      highlight effect for the unit.
      <ul>
      <li>Right-click on the <code>Unit</code> GameObject in the
      Hierarchy and select <strong>3D Object &gt; Cube</strong>.</li>
      <li>Rename it <code>HighlightMesh</code>.</li>
      </ul></li>
      <li>Adjust the <strong>Transform</strong> properties of
      <code>HighlightMesh</code> in the <strong>Inspector</strong>:
      <ul>
      <li>Set <strong>Scale</strong> to <code>(1.2, 0.1, 1.2)</code> to
      make it a flat, broad shape that extends slightly beyond the base
      of the unit.</li>
      <li>Set <strong>Position</strong> to <code>(0, 0.5, 0)</code> to
      place it just beneath the main unit mesh, creating a visible
      highlight around the base of the unit.</li>
      </ul></li>
      </ul>
      <h4 id="23-set-up-highlighters-for-visual-feedback">23.
      <strong>Set Up Highlighters for Visual Feedback</strong>:</h4>
      <ul>
      <li><p>To handle different visual states (e.g., selected,
      friendly, finished), add a new <strong>GameObject</strong> as a
      child of the <code>Unit</code> GameObject and name it
      <strong>Highlighters</strong>.</p>
      <ul>
      <li>Right-click on the <code>Unit</code> GameObject in the
      Hierarchy and select <strong>Create Empty</strong>. Rename it
      <code>Highlighters</code>.</li>
      </ul></li>
      <li><p>Add child <strong>GameObjects</strong> under
      <strong>Highlighters</strong> to represent each visual state.
      Attach the <code>RendererHighlighter.cs</code> script to each of
      these new GameObjects, then configure their properties:</p></li>
      </ul>
      <ul>
      <li><strong>UnMark</strong>:  
      <ul>
      <li>Create an empty <strong>GameObject</strong> named "UnMark" as
      a child of <code>Highlighters</code>.</li>
      <li>Attach the <code>RendererHighlighter.cs</code> script to
      it.</li>
      <li>On the <code>RendererHighlighter</code> component, set
      <code>_color</code> to white.</li>
      <li>Drag the <code>HighlightMesh</code> GameObject into the
      <code>_renderer</code> field.</li>
      </ul></li>
      </ul>
      <blockquote>
      <p>Tip: Copy the UnMark GameObject 4 times and adjust the
      parameters as below. This saves time and reduces repetitive setup
      by duplicating the GameObject with its attached script and
      assigned renderer.</p>
      </blockquote>
      <ul>
      <li><p><strong>MarkAsSelected</strong>:  </p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsSelected" as a child of <code>Highlighters</code>.</li>
      <li>Attach <code>RendererHighlighter.cs</code>.</li>
      <li>Set <code>_color</code> to blue.</li>
      <li>Assign the <code>HighlightMesh</code> to the
      <code>_renderer</code> field.</li>
      </ul></li>
      <li><p><strong>MarkAsFriendly</strong>:  </p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsFriendly" as a child of <code>Highlighters</code>.</li>
      <li>Attach <code>RendererHighlighter.cs</code>.</li>
      <li>Set <code>_color</code> to green.</li>
      <li>Assign the <code>HighlightMesh</code> to the
      <code>_renderer</code> field.</li>
      </ul></li>
      <li><p><strong>MarkAsFinished</strong>:  </p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsFinished" as a child of <code>Highlighters</code>.</li>
      <li>Attach <code>RendererHighlighter.cs</code>.</li>
      <li>Set <code>_color</code> to gray.</li>
      <li>Assign the <code>HighlightMesh</code> to the
      <code>_renderer</code> field.</li>
      </ul></li>
      <li><p><strong>MarkAsTargetable</strong>:  </p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsTargetable" as a child of <code>Highlighters</code>.</li>
      <li>Attach <code>RendererHighlighter.cs</code>.</li>
      <li>Set <code>_color</code> to red.</li>
      <li>Assign the <code>HighlightMesh</code> to the
      <code>_renderer</code> field.</li>
      </ul></li>
      <li><p><strong>MarkAsAttacking / MarkAsDefending</strong>:  </p>
      <ul>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsAttacking" as a child of <code>Highlighters</code>. Attach
      <code>SwayHighlighter.cs</code> to it.</li>
      <li>Create an empty <strong>GameObject</strong> named
      "MarkAsDefending" as a child of <code>Highlighters</code>. Attach
      <code>SwayHighlighter.cs</code> to it.</li>
      </ul></li>
      </ul>
      <h4
      id="24-configure-swayhighlighter-parameters-for-markasattacking-and-markasdefending">24.
      <strong>Configure SwayHighlighter Parameters for MarkAsAttacking
      and MarkAsDefending</strong>:</h4>
      <p>The <strong>SwayHighlighter</strong> provides a dynamic swaying
      effect, perfect for visually signaling a unit's aggressive or
      defensive state. Adjust the following parameters on the objects
      created in the previous step:</p>
      <ul>
      <li><p><strong>_magnitude</strong>: This controls the intensity of
      the sway, or how much the unit "leans" or "bobs" during the
      animation. Higher values will produce a more pronounced
      effect.</p>
      <ul>
      <li>For <strong>MarkAsAttacking</strong>: Set
      <code>_magnitude</code> to <code>0.5</code> for a noticeable sway
      when the unit is preparing to attack, giving a sense of forward
      motion.</li>
      <li>For <strong>MarkAsDefending</strong>: Set
      <code>_magnitude</code> to <code>-0.25</code>, creating a more
      subtle, backward lean that suggests a defensive stance.</li>
      </ul></li>
      <li><p><strong>_swayCurve</strong>: This parameter defines the
      swaying motion over time, represented by a <strong>Curve</strong>
      resource.</p></li>
      <li><p>Click on the <strong>Curve</strong> field in the Inspector,
      which opens a curve editor where you can control the sway's timing
      and smoothness.</p></li>
      <li><p>The sample curve includes three key points:</p>
      <ul>
      <li><code>Vector2(0, 0)</code>: The starting point, which defines
      the initial position.</li>
      <li><code>Vector2(0.5, 1)</code>: The peak of the sway at halfway,
      creating the maximum "lean."</li>
      <li><code>Vector2(1, 0)</code>: Returns the unit to its starting
      position at the end of the cycle.</li>
      </ul></li>
      <li><p>This curve can be adjusted as needed to make the sway
      faster, slower, or more dramatic by manipulating the height and
      position of these points.</p></li>
      <li><p><strong>_targetTransform</strong>: This field references
      the part of the unit affected by the sway. Set
      <code>_targetTransform</code> to the root <code>GameObject</code>
      so the sway applies to the entire unit.</p></li>
      </ul>
      <h4 id="25-assign-highlighters-to-fields-in-unit-script">25.
      <strong>Assign Highlighters to Fields in Unit Script</strong></h4>
      <p>With the highlighters set up, you’ll now assign each to the
      corresponding field in the <code>Unit.cs</code> script.</p>
      <ul>
      <li>Select the root unit GameObject, and in the Inspector, locate
      the properties for each highlighter under the <code>Unit.cs</code>
      script.</li>
      <li>Assign the highlighter nodes to their respective fields:
      <ul>
      <li><strong>_unMarkFn</strong>: Set to
      <code>Highlighters/UnMark</code>.</li>
      <li><strong>_markAsSelectedFn</strong>: Set to
      <code>Highlighters/MarkAsSelected</code>.</li>
      <li><strong>_markAsFriendlyFn</strong>: Set to
      <code>Highlighters/MarkAsFriendly</code>.</li>
      <li><strong>_markAsFinishedFn</strong>: Set to
      <code>Highlighters/MarkAsFinished</code>.</li>
      <li><strong>_markAsTargetableFn</strong>: Set to
      <code>Highlighters/MarkAsTargetable</code>.</li>
      <li><strong>_markAsAttackingFn</strong>: Set to
      <code>Highlighters/MarkAsAttacking</code>.</li>
      <li><strong>_markAsDefendingFn</strong>: Set to
      <code>Highlighters/MarkAsDefending</code>.</li>
      </ul></li>
      </ul>
      <h4 id="26-automatic-configuration-of-abilities-and-brain">26.
      <strong>Automatic Configuration of Abilities and
      Brain</strong></h4>
      <p>When you attach the <code>Unit</code> script to a GameObject,
      it automatically adds two basic abilities—<code>MoveAbility</code>
      and <code>AttackAbility</code>—to streamline the setup process.
      These default components provide core functionality for movement
      and combat.</p>
      <ul>
      <li>You may remove or replace these abilities later, but for the
      purposes of this tutorial, leave them as they are.</li>
      </ul>
      <p>Additionally, a default <code>BehaviourTreeResource</code> is
      assigned to the unit’s <code>Brain</code> object to provide basic
      AI behaviour.</p>
      <ul>
      <li>This behaviour tree can be customized as needed, but no
      changes are required for this tutorial.</li>
      </ul>
      <h4 id="27-save-the-unit-template">27. <strong>Save the Unit
      Template</strong>:</h4>
      <ul>
      <li>Save this unit prefab as the base template for units in the
      game. Drag the unit GameObject from the Hierarchy panel into the
      Project panel.</li>
      </ul>
      <h4 id="28-create-color-variations-for-each-player">28.
      <strong>Create Color Variations for Each Player</strong>:</h4>
      <ul>
      <li>To differentiate units for each player, create a <strong>new
      prefab variant</strong> from this base unit template for each
      player.</li>
      <li>Right-click on the unit prefab in the Project panel and select
      <strong>Create &gt; Prefab Variant</strong></li>
      <li>Create two new materials for each player
      <ul>
      <li>Right-click in the Project panel and select <strong>Create
      &gt; Material</strong></li>
      <li>Modify the <strong>Albedo</strong> property on each new
      material to a unique color (e.g., blue for Player 1 and red for
      Player 2).</li>
      </ul></li>
      <li>Assign the new materials to the <strong>UnitMesh</strong> of
      each prefab.</li>
      <li>Save each player’s unit prefab, and you’re ready to add these
      units to the game map.</li>
      </ul>
      <h4 id="29-adding-units-to-the-game-using-the-unit-painter">29.
      <strong>Adding Units to the Game Using the Unit
      Painter</strong></h4>
      <p>With the unit templates ready, you’ll use the <strong>Unit
      Painter</strong> feature in <strong>GridHelper</strong> to place
      the units on the map, allowing you to set up each player's
      units.</p>
      <ul>
      <li><p><strong>Open the Unit Painter</strong>:</p>
      <ul>
      <li>In the Unity Editor, navigate to the
      <strong>GridHelper</strong> panel.</li>
      <li>Find the <strong>Unit Painter</strong> section within the
      panel.</li>
      </ul></li>
      <li><p><strong>Select a Unit Prefab</strong>:</p>
      <ul>
      <li>In the <strong>Unit Painter</strong> panel, set the
      <strong>Unit Prefab</strong> field by selecting one of the
      player-specific unit prefabs you created earlier (e.g., the blue
      unit for the first player).</li>
      </ul></li>
      <li><p><strong>Assign Player Number</strong>:</p>
      <ul>
      <li>Set the <strong>Player Number</strong> field to match the
      player for whom you are placing units. For example, set it to
      <code>0</code> for the first player and <code>1</code> for the
      second player.</li>
      </ul></li>
      <li><p><strong>Enter Unit Edit Mode</strong>:</p>
      <ul>
      <li>Click <strong>Enter Unit Edit Mode</strong>. This enables
      placement mode on the grid, allowing you to place units by
      clicking on cells.</li>
      </ul></li>
      <li><p><strong>Place Units on the Map</strong>:</p>
      <ul>
      <li>Click on the cells where you want to place the units for the
      selected player. Place a few units for each player in different
      locations to set up the initial scene for gameplay.</li>
      </ul></li>
      <li><p><strong>Exit Unit Edit Mode</strong>:</p>
      <ul>
      <li>Once you’ve placed all desired units, click <strong>Exit Unit
      Edit Mode</strong> to finalize the setup and return to the
      standard editor view.</li>
      </ul></li>
      </ul>
      <h3 id="completing-the-tutorial">Completing the Tutorial</h3>
      <p>With the units placed, your turn-based strategy scene is now
      fully configured and ready for testing. You have set up a
      square-based grid, added obstacles, and placed two human players
      with units, all without writing any code. This provides a
      practical foundation for exploring the Turn-Based Strategy
      Framework further, including options for additional features or
      customization.</p>
      <p>Your scene is now ready to play and test. Open the scene in the
      Unity Editor, press <strong>Play</strong>, and observe the
      framework in action.</p>
      <h2
      id="11-beyond-the-basics-pushing-the-limits-of-the-turn-based-strategy-framework">11.
      Beyond the Basics: Pushing the Limits of the Turn-Based Strategy
      Framework</h2>
      <p>The previous chapters covered the core features and workflows,
      but the Framework offers far more for experienced developers
      willing to explore its full potential. This chapter is an
      open-ended collection of advanced use cases, that go beyond
      Turn-Based Strategy Framework basics.</p>
      <h3 id="1-using-unity-tilemap-system-for-maps">1. Using Unity
      Tilemap System for maps</h3>
      <p>In the basic setup, a map in the Framework consists of
      individual GameObjects, each representing a cell. This approach is
      intuitive—it’s easy to inspect, debug, and directly manipulate
      each cell in the editor. However, it doesn't scale well. Once you
      exceed a few hundred cells, performance becomes an issue.</p>
      <p>But a cell doesn't need to be a GameObject. It can be a
      lightweight C# class that implements the ICell interface, without
      any presence in the Unity scene hierarchy. When combined with a
      custom ICellManager implementation, this allows you to manage the
      grid purely in memory—drastically reducing overhead and enabling
      much larger maps.</p>
      <p>In the scene, such maps can be represented in different ways:
      as pre-made meshes, procedurally generated geometry, images,
      or—most effectively—using Unity’s Tilemap system. The Framework
      includes a demo using the Tilemap; you can find it in the
      <code>Examples/TilemapExample</code> folder and here's a short
      recap of how it's done:</p>
      <ul>
      <li>The Tilemap consists of two layers: a visual layer, where the
      map is drawn, and a data layer, where gameplay data (e.g. movement
      cost) is encoded.</li>
      <li>Instead of cell prefabs, the data layer is painted using
      DataTile tiles that store gameplay-related properties:</li>
      </ul>
      <div class="sourceCode" id="cb32"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DataTile <span class="op">:</span> Tile</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> movementCost <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">bool</span> isWalkable <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> ScriptableObject cellType<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <ul>
      <li>A custom <code>TilemapCellManager</code> replaces the default
      <code>RegularCellManager</code> in the scene. It reads from the
      data layer and builds the in-memory grid:</li>
      </ul>
      <div class="sourceCode" id="cb33"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Initialize</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    BoundsInt bounds <span class="op">=</span> _tilemap<span class="op">.</span><span class="fu">cellBounds</span><span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    _cells <span class="op">=</span> <span class="kw">new</span> Dictionary<span class="op">&lt;</span>IVector2Int<span class="op">,</span> VirtualSquareCell<span class="op">&gt;();</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">foreach</span> <span class="op">(</span>Vector3Int pos <span class="kw">in</span> bounds<span class="op">.</span><span class="fu">allPositionsWithin</span><span class="op">)</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        DataTile tile <span class="op">=</span> _tilemap<span class="op">.</span><span class="fu">GetTile</span><span class="op">&lt;</span>DataTile<span class="op">&gt;(</span>pos<span class="op">);</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>tile <span class="op">==</span> <span class="kw">null</span><span class="op">)</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">continue</span><span class="op">;</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> worldPosition <span class="op">=</span> _tilemap<span class="op">.</span><span class="fu">GetCellCenterWorld</span><span class="op">(</span>pos<span class="op">).</span><span class="fu">ToIVector3</span><span class="op">();</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> gridPosition <span class="op">=</span> <span class="kw">new</span> <span class="fu">Vector2IntImpl</span><span class="op">(</span>pos<span class="op">.</span><span class="fu">x</span><span class="op">,</span> pos<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> cell <span class="op">=</span> <span class="kw">new</span> <span class="fu">VirtualSquareCell</span><span class="op">(</span>gridPosition<span class="op">,</span> worldPosition<span class="op">,</span> tile<span class="op">.</span><span class="fu">movementCost</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span> tile<span class="op">.</span><span class="fu">cellType</span><span class="op">);</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        _cells<span class="op">.</span><span class="fu">Add</span><span class="op">(</span>gridPosition<span class="op">,</span> cell<span class="op">);</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>        CellAdded<span class="op">?.</span><span class="fu">Invoke</span><span class="op">(</span>cell<span class="op">);</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    _selectedCell <span class="op">=</span> _cells<span class="op">.</span><span class="fu">Values</span><span class="op">.</span><span class="fu">First</span><span class="op">();</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
      <h3 id="2-porting-to-other-engines">2. Porting to other
      engines</h3>
      <p>The core of the Framework's code is written in a way that's
      decoupled from any specific engine dependencies. This makes it
      easy to port your gameplay to different game engine that uses C#
      for scripting. To facilitate the transition, I would advice to
      structure your code in the folowing way: whenever possible, make
      your mechanics engine-agnostic. Then, reference this
      implementation in engine-specific code. This is how
      <code>AttackAbility</code> and <code>MoveAbility</code> are
      implemented in the Framework:</p>
      <ul>
      <li>The underlying logic is implemented in common
      <code>AttackAbilityImpl</code> class:</li>
      </ul>
      <div class="sourceCode" id="cb34"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> AttackAbilityImpl <span class="op">:</span> IAbility</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">OnAbilitySelected</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">var</span> enemyUnits <span class="op">=</span> gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">GetEnemyUnits</span><span class="op">(</span>gridController<span class="op">.</span><span class="fu">TurnContext</span><span class="op">.</span><span class="fu">CurrentPlayer</span><span class="op">);</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        _attackableUnits <span class="op">=</span> <span class="kw">new</span> HashSet<span class="op">&lt;</span>IUnit<span class="op">&gt;(</span>enemyUnits<span class="op">.</span><span class="fu">Where</span><span class="op">(</span>u <span class="op">=&gt;</span> UnitReference<span class="op">.</span><span class="fu">IsUnitAttackable</span><span class="op">(</span>u<span class="op">,</span> u<span class="op">.</span><span class="fu">CurrentCell</span><span class="op">,</span> UnitReference<span class="op">.</span><span class="fu">CurrentCell</span><span class="op">)));</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> async <span class="dt">void</span> <span class="fu">Display</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        await gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">MarkAsTargetable</span><span class="op">(</span>_attackableUnits<span class="op">);</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">CleanUp</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        gridController<span class="op">.</span><span class="fu">UnitManager</span><span class="op">.</span><span class="fu">UnMark</span><span class="op">(</span>_attackableUnits<span class="op">);</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The rest of the methods skipped for brevity</span></span></code></pre></div>
      <ul>
      <li>Then, the actual Unity implementation references this code
      like this:</li>
      </ul>
      <div class="sourceCode" id="cb35"><pre
      class="sourceCode csharp"><code class="sourceCode cs"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> AttackAbility <span class="op">:</span> Ability</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> AttackAbilityImpl _attackAbility<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Initialize</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">base</span><span class="op">.</span><span class="fu">Initialize</span><span class="op">(</span>gridController<span class="op">);</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        _attackAbility <span class="op">=</span> <span class="kw">new</span> <span class="fu">AttackAbilityImpl</span><span class="op">(</span>UnitReference<span class="op">);</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        _attackAbility<span class="op">.</span><span class="fu">Initialize</span><span class="op">(</span>gridController<span class="op">);</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">Display</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>        _attackAbility<span class="op">.</span><span class="fu">Display</span><span class="op">(</span>gridController<span class="op">);</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">CleanUp</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>        _attackAbility<span class="op">.</span><span class="fu">CleanUp</span><span class="op">(</span>gridController<span class="op">);</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">override</span> <span class="dt">void</span> <span class="fu">OnAbilitySelected</span><span class="op">(</span>IGridController gridController<span class="op">)</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>        _attackAbility<span class="op">.</span><span class="fu">OnAbilitySelected</span><span class="op">(</span>gridController<span class="op">);</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The rest of the methods skipped for brevity</span></span></code></pre></div>
      <p>By structuring your code in this way you can make your codebase
      futureproof and greaty simplify the porting process.</p>
      <p><strong>More ideas to come!</strong></p>
      <h2 id="12-support">12. Support</h2>
      <p>Thanks for choosing the Turn-Based Strategy Framework! If you
      have any questions, need help setting things up, or just want to
      chat about what you're building, I’d love to hear from you. There
      are a couple of ways to reach out, so pick what works best for
      you. You can always email me directly at <a
      href="mailto:crookedhead@outlook.com">crookedhead@outlook.com</a>,
      or, if you prefer live conversations, join the community on
      Discord at <a
      href="https://discord.com/invite/uBJNPJHFjB">https://discord.com/invite/uBJNPJHFjB</a>.
      The Discord server is a great place to get quick answers, see what
      others are creating, and maybe even find some inspiration. I do my
      best to respond quickly throughout the week. Looking forward to
      helping you bring your game to life!</p>
      <h2 id="13-conclusion">13. Conclusion</h2>
    </article>
  </body>
</html>
